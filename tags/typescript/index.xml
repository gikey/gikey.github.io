<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>TypeScript on Null</title><link>https://www.xieluping.cn/tags/typescript/</link><description>Recent content in TypeScript on Null</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Sun, 12 Sep 2021 16:17:05 +0800</lastBuildDate><atom:link href="https://www.xieluping.cn/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>TypeScript 中 is 类型保护</title><link>https://www.xieluping.cn/post/typescript-is/</link><pubDate>Sun, 12 Sep 2021 16:17:05 +0800</pubDate><guid>https://www.xieluping.cn/post/typescript-is/</guid><description>前言 在阅读 utility-types 源码中发现了一段代码：
// export type Falsy = false | &amp;#39;&amp;#39; | 0 | null | undefined; export const isFalsy = (val: unknown): val is Falsy =&amp;gt; !val; 这里的返回类型不应该是 boolean 吗？ 为什么要使用 val is Falsy？
type guard 看到网上有这样一个例子：
function isString(test: any): boolean { return typeof test === &amp;#34;string&amp;#34;; } function example(foo: any){ if(isString(foo)){ console.log(&amp;#34;it is a string&amp;#34; + foo); console.log(foo.length); // string function } } example(&amp;#34;hello world&amp;#34;); 在这种情况下，返回类型定义为 boolean 和 test is string 其实没有区别。但是如果这个时候不小心在 if 中调用了一个不存在的方法会怎么样呢？例如：</description></item></channel></rss>