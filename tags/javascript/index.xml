<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>JavaScript on Null</title><link>https://gikey.github.io/tags/javascript/</link><description>Recent content in JavaScript on Null</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Thu, 08 Mar 2018 17:33:31 +0800</lastBuildDate><atom:link href="https://gikey.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript 任务和事件循环</title><link>https://gikey.github.io/post/event-loop/</link><pubDate>Thu, 08 Mar 2018 17:33:31 +0800</pubDate><guid>https://gikey.github.io/post/event-loop/</guid><description>js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。
First 首先来看下面一段代码：
console.log(&amp;#39;script start&amp;#39;); setTimeout(function() { console.log(&amp;#39;setTimeout&amp;#39;); }, 0); Promise.resolve().then(function() { console.log(&amp;#39;promise1&amp;#39;); }).then(function() { console.log(&amp;#39;promise2&amp;#39;); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'
执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：
function a() { console.log(&amp;#39;a&amp;#39;); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?
console.log(&amp;#34;sync&amp;#34;); $.on(&amp;#39;button&amp;#39;, &amp;#39;click&amp;#39;, function onClick() { setTimeout(function timer() { console.log(&amp;#39;You clicked the button!&amp;#39;); }, 2000); }); setTimeout(function timeout() { console.log(&amp;#34;Click the button!</description></item><item><title>JavaScript instanceof 操作符</title><link>https://gikey.github.io/post/instanceof/</link><pubDate>Fri, 18 Aug 2017 12:51:54 +0800</pubDate><guid>https://gikey.github.io/post/instanceof/</guid><description>instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 &amp;ldquo;object&amp;rdquo;。例如：
var arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：
var arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ?</description></item></channel></rss>