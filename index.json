[{"content":"什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：\n Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：\n 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define(\u0026#39;my-element\u0026#39;, WordCount, { extends: \u0026#39;p\u0026#39; }); custom elements 可以分为两种：\n Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(\u0026quot;my-element\u0026quot;)。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称\u0026lt;p is=\u0026quot;my-element\u0026quot;\u0026gt;, 或者 document.createElement(\u0026quot;p\u0026quot;, { is: \u0026quot;my-element\u0026quot; })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   \u0026lt;my-element name=\u0026#34;web component\u0026#34;\u0026gt;\u0026lt;/my-element \u0026gt; \u0026lt;script\u0026gt; class MyElement extends HTMLElement { connectedCallback() { const shadow = this.attachShadow({mode: \u0026#39;open\u0026#39;}); shadow.innerHTML = `\u0026lt;p\u0026gt; Hello, ${this.getAttribute(\u0026#39;name\u0026#39;)}\u0026lt;/p\u0026gt;`; } } window.customElements.define(\u0026#39;my-element\u0026#39;, MyElement); \u0026lt;/script\u0026gt; HTML Templates \u0026lt;template\u0026gt; 是一种 HTML 元素，所以一个含内容的模板所具备的最基本形式如下：\n\u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;Hello world\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 在浏览器中运行这段代码会显示空白页面，因为浏览器并没有渲染模板元素内容。这种方式的强大之处在于它允许我们保存自定义内容（或内容结构），以供后续使用，而不需要使用 JavaScript 来动态编写 HTML 代码。 模板可以包含任意 HTML，包括脚本和样式元素。例如：\n\u0026lt;template id=\u0026#34;template\u0026#34;\u0026gt; \u0026lt;script\u0026gt; const button = document.getElementById(\u0026#39;click-me\u0026#39;); button.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; alert(event)); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #click-me { all: unset; background: tomato; border: 0; border-radius: 4px; color: white; font-family: Helvetica; font-size: 1.5rem; padding: .5rem 1rem; } \u0026lt;/style\u0026gt; \u0026lt;button id=\u0026#34;click-me\u0026#34;\u0026gt;Log click event\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;slot\u0026gt; 使用与 Vue 的用法基本一模一样\n\u0026lt;!-- my-paragraph --\u0026gt; \u0026lt;p\u0026gt;\u0026lt;slot name=\u0026#34;my-text\u0026#34;\u0026gt;My default text\u0026lt;/slot\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;my-element\u0026gt; \u0026lt;span slot=\u0026#34;my-text\u0026#34;\u0026gt;Let\u0026#39;s have some different text!\u0026lt;/span\u0026gt; \u0026lt;/my-element\u0026gt; 生命周期  constructor：组件被 create 的时候会被调用，整个生命周期中最早触发也只会触发一次，通常可以在这里做一些初始化私有变量、记录数据的一些操作；但是出于性能和职责分离的考虑，不建议在这里做一些 DOM 相关的事情。 connectedCallback：组件被连接到 DOM Tree 的时候会触发，这个时机包括节点被插入节点树、节点被从节点树中移动，所以它可能会被触发多次。 disconnectedCallback：组件被从 DOM Tree 中移除的时候触发。 adoptedCallback：当 custom element被移动到新的文档时，被调用。adoptNode attributeChangedCallback：当组件的 attribute 发生变化的时候触发，它的三个形参分别是 name, oldValue, newValue，如果声明了 properties 对象，对 attribute 的相应值变化也会触发这个回调。需要注意的是，如果覆盖了组件的 observedAttributes 静态方法，properties 对象中声明的值不会触发，它会按照覆盖的 observedAttributes 静态方法的返回值为准。  class MyComponent extends HTMLElement { constructor() { super() } connectedCallback(){ // 当自定义元素第一次被连接到文档DOM时被调用  } disconnectedCallback(){ // 当自定义元素与文档DOM断开连接时被调用  } adoptedCallback(){ // 当自定义元素被移动到新文档时被调用  } attributeChangedCallback(){ // 当自定义元素的一个属性被增加、移除或更改时被调用  } } 组件通信 父组件传递数据给子组件  通过 DOM 属性，不支持复杂对象的传递。  // parentWc const parentTemplate = `\u0026lt;child-wc/\u0026gt;`; class ParentWc extends HTMLElement { // ...  connectedCallback() { const child = this.shadowRoot.querySelector(\u0026#39;child-wc\u0026#39;) child.setAttribute(\u0026#39;text\u0026#39;, \u0026#39;web component\u0026#39;); } } window.customElements.define(\u0026#39;parent-wc\u0026#39;, ParentWc) // childWc class ChildWc extends HTMLElement { // 必须先生命需要监听的属性  static get observedAttributes() { return [\u0026#39;text\u0026#39;]; } attributeChangedCallback(name, oldValue, newValue) { if(name===\u0026#39;text\u0026#39; \u0026amp; oldValue !== newValue) { console.log(newValue) } } } window.customElements.define(\u0026#39;child-wc\u0026#39;, ChildWc); 第二种方式通过组件实例属性。这是目前主流的传值方式，支持复杂对象的传递。  // parentWc class ParentWc extends HTMLElement { // ...  connectedCallback() { this.shadowRoot.querySelector(\u0026#39;child-wc\u0026#39;).data.text = { type: \u0026#39;web component\u0026#39;} } } window.customElements.define(\u0026#39;parent-wc\u0026#39;, ParentWc) // childWc class ChildWc extends HTMLElement { constructor() { super(); this.data = {text: {type: \u0026#39;child web component\u0026#39; } } Object.defineProperty(this.data, \u0026#39;text\u0026#39;, { set: value =\u0026gt; { console.log(value) } }) } } 子组件传递数据给父组件  第一种通过事件监听，利用原生 CustomEvent 函数来创建自定义事件，然后在子组件实例上派发此事件以及数据，同时父组件进行监听，可以借助 document 设置事件总线，进行跨组件全局通信。  // childWc class ChildWc extends HTMLElement { // ...  connectedCallback() { const event = new CustomEvent(\u0026#39;custom-event\u0026#39;, { detail: { value: \u0026#39;child web component\u0026#39; } }); this.dispatchEvent(event); } window.customElements.define(\u0026#39;child-wc\u0026#39;, ChildWc) // parentWc class ParentWc extends HTMLElement { // ...  connectedCallback() { const child = this.shadowRoot.querySelector(\u0026#39;child-wc\u0026#39;) child.addEventListener(\u0026#39;custom-event\u0026#39;, ({ detail }) =\u0026gt; { console.log(detail.value); }) } } window.customElements.define(\u0026#39;parent-wc\u0026#39;, ParentWc) 第二种方式是直接调用父组件方法。  // parentWc class ParentWc extends HTMLElement { // ...  say(msg) { console.log(msg); } } window.customElements.define(\u0026#39;parent-wc\u0026#39;, ParentWc) class ChildWc extends HTMLElement { // ...  connectedCallback() { this.getRootNode().host.say(\u0026#39;child web component\u0026#39;) } } window.customElements.define(\u0026#39;child-wc\u0026#39;, ChildWc) Shadow DOM 样式封装 目前，定义一个 shadow DOM 节点样式的唯一方法就是在 shadow root 的内部 HTML 中添加一个 \u0026lt;style\u0026gt; 元素。这种方法几乎在所有情况下都能正常工作，因为浏览器会在可能的情况下对这些组件中的样式表进行重写。在 shadow DOM 中我们可以使用link 或者 @import 引入外部样式，但是必须明确元素样式表的位置。\nslot 节点设定样式 不会移动用户的 Light DOM，中内容依然会在原处，这就意味着可以直接在外层直接设置对应的样式。 \u0026lt;style\u0026gt; h1 { ... } \u0026lt;/style\u0026gt; \u0026lt;my-counter\u0026gt; \u0026lt;h1 slot=\u0026#34;title\u0026#34;\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;/my-counter\u0026gt; ::slotted\u0026lt;selector\u0026gt; 可以在 shadow DOM 中为\u0026lt;slot\u0026gt;中节点设置样式，::slotted\u0026lt;selector\u0026gt;设置的样式只能在最顶层的节点生效：\n\u0026lt;!-- my-counter --\u0026gt; \u0026lt;style\u0026gt; ::slotted { color: red; } ::slotted(.description) { color: blue; } \u0026lt;!-- 不生效 --\u0026gt; ::slotted(.lib)， ::slotted(.description .lib) { color: green; } \u0026lt;/style\u0026gt; \u0026lt;my-countr\u0026gt; \u0026lt;h1 slot=\u0026#34;title\u0026#34;\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;description\u0026#34;\u0026gt; A counter build by \u0026lt;span class=\u0026#34;\u0008lib\u0026#34;\u0026gt;web component\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/my-counter\u0026gt; css 自定义属性 css 自定义属性可以传入 shadow DOM 内部，从而调整内部样式，从概念上看，这与\u0026lt;slot\u0026gt;类似， 可以简单理解为：创建“样式占位符”以便进行替换：\n\u0026lt;!-- main page --\u0026gt; \u0026lt;style\u0026gt; :root { --primary: red; } \u0026lt;/style\u0026gt; \u0026lt;!-- my-counter --\u0026gt; \u0026lt;style\u0026gt; div { background-color: var(--primary, blue); } \u0026lt;/style\u0026gt; 可构造的样式表 为了更好地复用样式，可构造的样式表提供了类似于编写普通 CSS 并在多个节点之间共享这些样式的方式。\nconst everythingTomato = new CSSStyleSheet(); everythingTomato.replace(\u0026#39;* { color: tomato; }\u0026#39;); document.adoptedStyleSheets = [everythingTomato]; class MyCounter extends HTMLElement { constructor() { super(); this.adoptedStyleSheets = [everythingTomato]; } connectedCallback() { this.shadowRoot.innerHTML = `\u0026lt;h1\u0026gt;CSS colors are fun\u0026lt;/h1\u0026gt;`; } } part 伪元素 ::part 可以结合其他伪类/元素使用，不能再加上选择器\n\u0026lt;!-- main page --\u0026gt; \u0026lt;style\u0026gt; tab-element::part(tab) { color: grey; } tab-element::part(tab):hover { color: black; } tab-element::part(active) { color: black; } \u0026lt;!-- 不生效 --\u0026gt; tab-element::part(tab) span { color: white; } \u0026lt;/style\u0026gt; \u0026lt;!-- tab-element --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div part=\u0026#34;tab active\u0026#34;\u0026gt; \u0026lt;span part=\u0026#34;tab\u0026#34;\u0026gt; tab1 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div part=\u0026#34;tab\u0026#34;\u0026gt; \u0026lt;span\u0026gt; tab2 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Demo: 实现计数器 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;web component demo\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; justify-content: center; padding: 50px; } h1 { font-size: 30px; text-align: center; margin-bottom: 40px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;my-counter\u0026gt; \u0026lt;h1 slot=\u0026#34;title\u0026#34;\u0026gt;Counter\u0026lt;/h1\u0026gt; \u0026lt;/my-counter\u0026gt; \u0026lt;template\u0026gt; \u0026lt;style\u0026gt; span { width: 4rem; display: inline-block; text-align: center; } button { width: 4rem; height: 4rem; border: none; border-radius: 10px; background-color: seagreen; color: white; } \u0026lt;/style\u0026gt; \u0026lt;slot name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;button id=\u0026#34;dec\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span id=\u0026#34;count\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;inc\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; const template = document.querySelector(\u0026#34;template\u0026#34;); class MyCounter extends HTMLElement { constructor() { super(); this.count = 0; this.attachShadow({ mode: \u0026#34;open\u0026#34; }); } connectedCallback() { this.shadowRoot.appendChild(template.content.cloneNode(true)); this.shadowRoot.getElementById(\u0026#34;inc\u0026#34;).onclick = () =\u0026gt; this.inc(); this.shadowRoot.getElementById(\u0026#34;dec\u0026#34;).onclick = () =\u0026gt; this.dec(); this.update(this.count); } inc() { this.update(++this.count); } dec() { this.update(--this.count); } update(count) { this.shadowRoot.getElementById(\u0026#34;count\u0026#34;).innerHTML = count; } } window.customElements.define(\u0026#34;my-counter\u0026#34;, MyCounter); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Live demo: https://webcomponents.dev/edit/Osbw4TzJEizqkd5ZkHOs/www/index.html\n与现代框架对比 https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/\nBundle Size 上面计数器基于各种框架/库实现rollup打包大小如下： 单个组件： 打包30个： Performance 单个页面中 50个 JS 解析+DOM Tree 创建耗时： 开源实现 React/Vue  React 和 Web Components 为了解决不同的问题而生。Web Components 为可复用组件提供了强大的封装，而 React 则提供了声明式的解决方案，使 DOM 与数据保持同步。两者旨在互补。作为开发人员，可以自由选择在 Web Components 中使用 React，或者在 React 中使用 Web Components，或者两者共存。 React 和 Vue 开发 Web Component 的思路基本一样，都是用 Custom Elements 包装对应的 React/Vue 组件，以React 为例：\n import React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom\u0026#39;; export default function defineElement(Component, elementName, observedAttributes = [], events = []) { class CustomElement extends HTMLElement { constructor() { super(); observedAttributes.forEach(property =\u0026gt; Object.defineProperty(this, property, { set: value =\u0026gt; this.setterProxy(property, value) })); this.events = events; } setterProxy(name, value) { this.attributeChangedCallback(name, value, value); // Careful, this is a bug, since the oldVal always equals the new val  } connectedCallback() { const props = [...this.attributes].reduce((props, attribute) =\u0026gt; ({ ...props, [attribute.name]: attribute.value }), { root: this }); const instance = (\u0026lt;Component {...(props)} /\u0026gt;); this.assignEvents(instance); ReactDOM.render(instance, this); this.instance = instance; this.props = props; } attributeChangedCallback(name, oldValue, newValue) { const { instance } = this; if (!instance) return; const newProps = { ...(this.props), ...({ [name]: newValue }) }; const newInstance = (\u0026lt;Component {...(newProps)} /\u0026gt;); this.assignEvents(newInstance); ReactDOM.render(newInstance, this); this.instance = newInstance; this.props = newProps; } assignEvents(instance) { this.events.forEach(event =\u0026gt; instance.props[event] = eventArgs =\u0026gt; this.dispatchEvent(new CustomEvent(event, { detail: eventArgs }))); } } CustomElement.observedAttributes = observedAttributes; window.customElements.define(elementName, CustomElement);  React 基于 bitovi/react-to-webcomponent 实现 React 转换 Web Component； Vue 基于 https://cli.vuejs.org/zh/guide/build-targets.html 设置构建目标为 wc 来产出 Web Component，也可以 https://github.com/vuejs/vue-web-component-wrapper 包装一下（需配合vue-style-loader）\n Lit Lit 是 Google 提供的一组开源库，可帮助开发者构建快速、轻量且适用于任何框架的组件，Lit vs React，上面计数器用Lit实现就变得非常简单：\nimport { LitElement, html, css } from \u0026#34;lit\u0026#34;; import { customElement, property } from \u0026#34;lit/decorators.js\u0026#34;; @customElement(\u0026#34;my-counter\u0026#34;) export class MyCounter extends LitElement { static styles = css` div { display: inline-block; text-align: center; font-size: 30px; width: 50px; text-align: center; } button { width: 4rem; height: 4rem; border: none; border-radius: 10px; background-color: seagreen; color: white; font-size: 40px; } `; @state({type: Number}) count: number = 0; render() { return html` \u0026lt;slot name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;button @click=${() =\u0026gt; this.count--}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;${this.count}\u0026lt;/div\u0026gt; \u0026lt;button @click=${() =\u0026gt; this.count++}\u0026gt;+\u0026lt;/button\u0026gt; `; } }  “传统框架和 Web Components 结合最大的问题就在于运行时：单独分发的 WC 里面直接打包框架运行时，等于每个组件都要复制一份框架；不打包的话，又做不到开箱即用”。如何看待svelte 这个前端框架，Svelte 解决方案：https://dev.to/silvio/how-to-create-a-web-components-in-svelte-2g4j 跨框架使用 Demo 详见：https://webcomponents.dev/edit/8FfjYicF2OClmsUFivj0/www/index.html\n 兼容性  https://caniuse.com/?search=web%20components 对于不兼容的浏览器可以使用polyfills: webcomponents / polyfills，能够支持到IE11。\n 优势\u0026amp;劣势 优势：  原生支持，web components 依赖浏览器底层的实现，而不限定于某个特定的前端框架 Shadow DOM 实现了真正的局部 CSS 作用域 标准，只有 HTML，CSS，JavaScript，使用它可以不像使用依赖库或者框架的组件一样去额外学习一些框架的特定语言。  劣势：  API 偏底层操作，易用性不够 Css-in-js，性能、可读性差 全局命名空间 DOM操作，影响应用性能？ 发展缓慢  参考文档：  https://developers.google.cn/web/fundamentals/web-components https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/ https://dev.to/emileperron/web-components-in-2021-the-good-the-bad-and-the-ugly-3kg https://labs.thisdot.co/author/luis-aviles https://css-tricks.com/encapsulating-style-and-structure-with-shadow-dom/ https://vaadin.com/learn/tutorials/lit-element/state-management-with-redux https://github.com/obetomuniz/awesome-webcomponents https://github.com/nepaul/awesome-web-components  转载请注明出处和本文链接\n","permalink":"https://www.xieluping.cn/post/wc/","summary":"什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：\n Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：\n 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define(\u0026#39;my-element\u0026#39;, WordCount, { extends: \u0026#39;p\u0026#39; }); custom elements 可以分为两种：\n Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(\u0026quot;my-element\u0026quot;)。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称\u0026lt;p is=\u0026quot;my-element\u0026quot;\u0026gt;, 或者 document.createElement(\u0026quot;p\u0026quot;, { is: \u0026quot;my-element\u0026quot; })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   \u0026lt;my-element name=\u0026#34;web component\u0026#34;\u0026gt;\u0026lt;/my-element \u0026gt; \u0026lt;script\u0026gt; class MyElement extends HTMLElement { connectedCallback() { const shadow = this.","title":"基于 Web Components 跨框架组件开发"},{"content":"2020年12月21日 React 官方公布了一个新的提案 React Server Component（后面简称：RSC），并做了视频介绍和 demo (如果跑不起来建议尝试docker)演示。React Server Component 还在研发中，目前还是个试验性的功能，主要目的是为了从社区收到一些反馈。离正式发布还需要较长时间，暂时不用立即跟进学习。接下来主要做个简单的介绍。\nWeb 渲染的演化 一、Web1.0 服务端渲染 为了区分目前常说的“服务端渲染”，暂且把没有 Ajax 时代的服务端渲染称为“Web1.0 服务端渲染”。Web1.0 的时候前后端不分离，后端提供数据和模板渲染相应 HTML 页面，前端主要提供页面样式和js实现交互动效果。\n渲染流程：  客户端发起页面请求 服务端查询数据并使用相应的模板引擎渲染成 HTML 片段 客户端收到返回 HTML 解析成可见网页内容   优点：  友好的 SEO，每个页面都是服务端返回的完整的 HTML 首屏加载快，页面由后端渲染完成  缺点：  前后端耦合严重，前后端开发相互依赖 交互体验不佳，每个路由都需要页面刷新 服务端负载压力大，渲染任务都由服务端也丧失了客户端作为天然分布式系统的优势  二、客户端渲染（CSR） 随着前端页面复杂程度加剧和 Web2.0 Ajax 技术的发展，就有了前后端分离概念。以 Anglular 为代表的现代前端框架让这种后端提供接口，前端渲染页面的开发方式得到普及。也让服务端和客户端职责得到了明确的分工，让客户端和服务端各自实现更擅长的事情。 渲染流程：\n 客户端发起请求并接收返回的 HTML 内容 客户端解析网页内容并执行 JS 脚本 JS 利用 Ajax请求后端数据（json/xml） JS 动态将数据渲染在页面中   优点：  前后端分离模式，前端专注于UI，后端专注于逻辑 良好的交互体验，局部进行刷新，可以实现单页应用，预加载等提升页面性能 降低服务器压力，部署比较简单节约服务器成本  缺点：  不利于 SEO，页面数据都是动态生成不利于 SEO 优化 首屏白屏，首次请求几乎空白的 HMTL 页面，TTI受限于数据获取和浏览器渲染的耗时  三、服务端渲染（SSR） 随着单页应用的发展，不友好的 SEO 和首屏渲染白屏等问题亟待解决，于是再次考虑引入服务端渲染。主要逻辑是将 Web1.0 服务端渲染和 CSR 做了一个结合，以单页应用为例：前端服务器获取首屏数据通过服务端渲染成相应HTML返回客户端，之后的数据交互逻辑与客户端渲染一样。 渲染流程：\n 客户端向前端服务器发送页面请求 前端服务器向后端服务器请求相应数据并渲染完整 HTML 返回给客户端 客户端渲染 HTML 页面并执行 JS 脚本，给页面绑定事件，让页面变得可交互 当再次需要数据交互就于CSR一致利用 Ajax 请求服务端 API，拿到返回数据进行动态渲染   优点：  友好的 SEO，首屏不再是空白页面 良好的交互体验，既解决了首屏白屏的问题，也兼顾了 CSR 的优势  缺点：  维护困难，抛弃了部分 SPA 技术带来的技术优势 首屏无法分段渲染   RSC 并不是为了解决 SSR 渲染的问题而出现的， SSR 和 RSC 可以一起使用。\n RSC 到底是啥？ 以官方的介绍为例，有如下这样一个音乐详情页面： 我们的代码基本结构可能是这样：\nfunction ArtistPage({ artistId }) { return ( \u0026lt;ArtistDetails artistId={artistId}\u0026gt; \u0026lt;TopTracks artistId={artistId} /\u0026gt; \u0026lt;Discography artistId={artistId} /\u0026gt; \u0026lt;/ArtistDetails\u0026gt; ); } 为了保证良好的用户体验，我们会在一个接口中获取所有相关数据，避免随机顺序渲染：\nfunction ArtistPage({ artistId }) { const stuff = fetchAllTheStuffJustInCase(); return ( \u0026lt;ArtistDetails artistId={artistId} details={stuff.details} \u0026gt; \u0026lt;TopTracks artistId={artistId} topTracks={stuff.topTracks} /\u0026gt; \u0026lt;Discography artistId={artistId} discography={stuff.discography} /\u0026gt; \u0026lt;/ArtistDetails\u0026gt; ); } 这样每个组件从逻辑上就不那么解耦了，会让组件的可维护性变得非常差。如果后续不再需要 TopTracks 数据了，接口就返回了冗余的数据，或者某个组件增加了一个 props 属性，如果这个组件在其他地方也被用到，这样需要在其他所有地方都要增加这个 props 属性。 其实这个问题可用通过 GraphQL + Relay 的方案解决 于是我们考虑到可以让每个组件单独来实现各自数据获取逻辑：\nfunction ArtistDetails({ artistId, children }) { const detail = fetchDetails(artistId); // ... } function TopTracks({ artistId }) { const topTracks = fetchTopTracks(artistId); // ... } function Discography({ artistId }) { const discography = fetchDiscography(artistId); // ... } 这样在父组件 ArtistDetails 中的实现可能是这样：\nfunction ArtistDetails({ artistId, children }) { const [details, setDetails] = useState(null); useEffect(() =\u0026gt; { const detail = fetchArtistDetails(artistId); setArtistInfo(detail); }, [artistId]) if (!details) { return \u0026#39;loading\u0026#39;; } return ( \u0026lt;div\u0026gt; ... {children} \u0026lt;/div\u0026gt; ); } 也就是子组件中获取数据的逻辑必须要等到父组件渲染完毕，这种像瀑布一样一节一节往下流的模式就造成典型的网络瀑布，如果组件的数据源越多组件层级越深，问题越明显。 同时这样也会让体验变差，因为这个组件就需要发送3个 HTTP 请求，浏览器从服务端 fetch 数据是比较贵的 IO，抽象一下就是下面这样： 当然我们也可以让三个组件完全不嵌套平级展示，这样虽然避免了网络瀑布，但是组件的渲染顺序也变得不可控了，交互体验会再次打折扣 我们平时的组件数据交互基本都是这种模式。大胆设想下：如果把容器组件放在服务端，服务端的组件直接与数据交互生成完整组件内容然后返回给客户端，这样既可以解决频繁请求带来的 IO 消耗也解决了 CSR 中的网络瀑布。 到此，我们知道了 React Server Component 就是 在服务端运行的 React 组件。\nRSC 如何运行? 组件类型： 介绍 RSC 运行流程前需要先了解几个新的概念：\n  Server Component   服务器组件是在服务端运行的组件，它们可以直接访问服务器端数据源，比如服务器上的数据库或文件系统，因而获取数据取过程更快、更高效。服务器组件是无状态的，服务器组件可以导入客户端组件，客户端组件不能导入服务服务器组件，必须以 .server.js、.server.jsx 的格式命名。\n  Client Component   客户端组件是只能在客户端上呈现的组件（这就是我们目前使用的 react 组件）。客户端组件不能使用服务器组件。它们通常由服务器组件导入，用于显示应用程序的交互部分。它们不能访问服务器端数据源，它们是有状态的，可以访问浏览器 API，必须以 .client.js、.client.jsx 的格式命名。\n  Shared Component   共享组件是可以在服务端或客户端上呈现的组件，这具体取决于使用它们的组件类型。一般是Server Component 和 Client Component 共有的一些功能组成的组件，同样Shared Component也不能有状态。\n如果上面的 demo 抽象成在完全在客户端渲染的组件树可能是： 其实平时我们可以把组件划分为：依赖数据的容器组件和依赖行为的交互组件，容器组件其实可以运行在服务端交互组件可以运行在客户端。容器组件我们就可以用 Server Component 实现，而依赖行为的交互组件用 Client Component 实现： 运行流程  webpack 利用 react-server-dom-webpack/plugin 编译所有的 .client.js 文件，并生成 react-client-manifest.json 文件  { \u0026#34;file:///workspace/server-components-demo/src/Root.client.js\u0026#34;: { \u0026#34;\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;./src/Root.client.js\u0026#34;, \u0026#34;chunks\u0026#34;: [ \u0026#34;main\u0026#34; ], \u0026#34;name\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;*\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;./src/Root.client.js\u0026#34;, \u0026#34;chunks\u0026#34;: [ \u0026#34;main\u0026#34; ], \u0026#34;name\u0026#34;: \u0026#34;*\u0026#34; }, \u0026#34;default\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;./src/Root.client.js\u0026#34;, \u0026#34;chunks\u0026#34;: [ \u0026#34;main\u0026#34; ], \u0026#34;name\u0026#34;: \u0026#34;default\u0026#34; } // ... } Server 端启动服务，利用 react-server-dom-webpack/writer 的 pipeToNodeWritable 将 Server Component 和数据以及 react-client-manifest.json 转为 chunk 数据流返回客户端  const { pipeToNodeWritable } = require(\u0026#39;react-server-dom-webpack/writer\u0026#39;); async function renderReactTree(res, props) { await waitForWebpack(); const manifest = readFileSync( path.resolve(__dirname, \u0026#39;../build/react-client-manifest.json\u0026#39;), \u0026#39;utf8\u0026#39; ); const moduleMap = JSON.parse(manifest); pipeToNodeWritable(React.createElement(ReactApp, props), res, moduleMap); } M1:{\u0026#34;id\u0026#34;:\u0026#34;./src/SearchField.client.js\u0026#34;,\u0026#34;chunks\u0026#34;:[\u0026#34;client5\u0026#34;],\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;} M2:{\u0026#34;id\u0026#34;:\u0026#34;./src/EditButton.client.js\u0026#34;,\u0026#34;chunks\u0026#34;:[\u0026#34;client1\u0026#34;],\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;} S3:\u0026#34;react.suspense\u0026#34; J0:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;main\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;section\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;col sidebar\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;section\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-header\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;img\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;logo\u0026#34;,\u0026#34;src\u0026#34;:\u0026#34;logo.svg\u0026#34;,\u0026#34;width\u0026#34;:\u0026#34;22px\u0026#34;,\u0026#34;height\u0026#34;:\u0026#34;20px\u0026#34;,\u0026#34;alt\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;presentation\u0026#34;}],[\u0026#34;$\u0026#34;,\u0026#34;strong\u0026#34;,null,{\u0026#34;children\u0026#34;:\u0026#34;React Notes\u0026#34;}]]}],[\u0026#34;$\u0026#34;,\u0026#34;section\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-menu\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;menubar\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;@1\u0026#34;,null,{}],[\u0026#34;$\u0026#34;,\u0026#34;@2\u0026#34;,null,{\u0026#34;noteId\u0026#34;:null,\u0026#34;children\u0026#34;:\u0026#34;New2\u0026#34;}]]}],[\u0026#34;$\u0026#34;,\u0026#34;nav\u0026#34;,null,{\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;$3\u0026#34;,null,{\u0026#34;fallback\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;ul\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;notes-list skeleton-container\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;li\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;v-stack\u0026#34;,\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-note-list-item skeleton\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;5em\u0026#34;}}]}],[\u0026#34;$\u0026#34;,\u0026#34;li\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;v-stack\u0026#34;,\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-note-list-item skeleton\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;5em\u0026#34;}}]}],[\u0026#34;$\u0026#34;,\u0026#34;li\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;v-stack\u0026#34;,\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-note-list-item skeleton\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;5em\u0026#34;}}]}]]}]}],\u0026#34;children\u0026#34;:\u0026#34;@4\u0026#34;}]}]]}],[\u0026#34;$\u0026#34;,\u0026#34;section\u0026#34;,\u0026#34;null\u0026#34;,{\u0026#34;className\u0026#34;:\u0026#34;col note-viewer\u0026#34;,\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;$3\u0026#34;,null,{\u0026#34;fallback\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;note skeleton-container\u0026#34;,\u0026#34;role\u0026#34;:\u0026#34;progressbar\u0026#34;,\u0026#34;aria-busy\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;note-header\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;note-title skeleton\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;3rem\u0026#34;,\u0026#34;width\u0026#34;:\u0026#34;65%\u0026#34;,\u0026#34;marginInline\u0026#34;:\u0026#34;12px 1em\u0026#34;}}],[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;skeleton skeleton--button\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;width\u0026#34;:\u0026#34;8em\u0026#34;,\u0026#34;height\u0026#34;:\u0026#34;2.5em\u0026#34;}}]]}],[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;note-preview\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;skeleton v-stack\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;1.5em\u0026#34;}}],[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;skeleton v-stack\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;1.5em\u0026#34;}}],[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;skeleton v-stack\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;1.5em\u0026#34;}}],[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;skeleton v-stack\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;1.5em\u0026#34;}}],[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;skeleton v-stack\u0026#34;,\u0026#34;style\u0026#34;:{\u0026#34;height\u0026#34;:\u0026#34;1.5em\u0026#34;}}]]}]]}],\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;div\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;note--empty-state\u0026#34;,\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;span\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;note-text--empty-state\u0026#34;,\u0026#34;children\u0026#34;:\u0026#34;Click a note on the left to view something! ð¥º\u0026#34;}]}]}]}]]}] M5:{\u0026#34;id\u0026#34;:\u0026#34;./src/SidebarNote.client.js\u0026#34;,\u0026#34;chunks\u0026#34;:[\u0026#34;client6\u0026#34;],\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;} J4:[\u0026#34;$\u0026#34;,\u0026#34;ul\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;notes-list\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;li\u0026#34;,\u0026#34;3\u0026#34;,{\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;@5\u0026#34;,null,{\u0026#34;id\u0026#34;:3,\u0026#34;title\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;expandedChildren\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;p\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-note-excerpt\u0026#34;,\u0026#34;children\u0026#34;:\u0026#34;test demo\u0026#34;}],\u0026#34;children\u0026#34;:[\u0026#34;$\u0026#34;,\u0026#34;header\u0026#34;,null,{\u0026#34;className\u0026#34;:\u0026#34;sidebar-note-header\u0026#34;,\u0026#34;children\u0026#34;:[[\u0026#34;$\u0026#34;,\u0026#34;strong\u0026#34;,null,{\u0026#34;children\u0026#34;:\u0026#34;test\u0026#34;}],[\u0026#34;$\u0026#34;,\u0026#34;small\u0026#34;,null,{\u0026#34;children\u0026#34;:\u0026#34;12:32 noon\u0026#34;}]]}]}]}]]}] 客户端利用 react-server-dom-webpack 中 createFromFetch readRoot将获取的数据流反序列化为 React节点。   Server Component 中嵌套的 Client Component 则直接加载客户端.client.js 打包出来的 js 文件\n import { createFromFetch } from \u0026#34;react-server-dom-webpack\u0026#34;; function useServerResponse(id) { return createFromFetch(fetch(`/react?id=${id}`)); } function Content() { const [response, setResponse] = useState(); useEffect(() =\u0026gt; { setResponse(useServerResponse()); }, []); return response ? ( \u0026lt;div\u0026gt;{response.readRoot()}\u0026lt;/div\u0026gt; ) : null; } 整体流程如下： RSC 思考 RSC的思路其实很类似 PHP/ASP 时代的 Web1.0 服务端渲染，很多人认为是一种倒退，“前端好不容易爬到了山顶，却发现 PHP 已经等待多时”。盘点下 RSC 的一些优点和#### 缺点：\n缺点：  职责不清，RSC 的引入使得前后端分离的开发模式受到挑战，再次回到 Web1.0 的时代 维护困难，Server 组件和 Client 组件相互嵌套，代码维护会变得比 CSR 更加困难 增加了服务端压力，服务端需要额外将数据、jsx 转为 RSC 数据流传递给客户端  优点：  天然接近各种IO，访问数据库、文件系统更快、更高效 Zero Bundle Size，RSC 可以大大降低前端项目打包体积 Code Splitting，自动的代码分割 替代前端微服务，RSC 颗粒度是到组件级别，复用性能大大提高  哲学中有个理论叫做：“螺旋式上升”，RSC 并没有开倒车而是在一个更高的维度回来解决了一个老问题，这正是一种先进而优雅的方式。\n相关链接  https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html https://www.youtube.com/watch?v=TQQPAU21ZUw\u0026amp;feature=emb_title https://github.com/reactjs/server-components-demo https://github.com/reactjs/rfcs/pull/188  转载请注明出处和本文链接\n","permalink":"https://www.xieluping.cn/post/rsc/","summary":"2020年12月21日 React 官方公布了一个新的提案 React Server Component（后面简称：RSC），并做了视频介绍和 demo (如果跑不起来建议尝试docker)演示。React Server Component 还在研发中，目前还是个试验性的功能，主要目的是为了从社区收到一些反馈。离正式发布还需要较长时间，暂时不用立即跟进学习。接下来主要做个简单的介绍。\nWeb 渲染的演化 一、Web1.0 服务端渲染 为了区分目前常说的“服务端渲染”，暂且把没有 Ajax 时代的服务端渲染称为“Web1.0 服务端渲染”。Web1.0 的时候前后端不分离，后端提供数据和模板渲染相应 HTML 页面，前端主要提供页面样式和js实现交互动效果。\n渲染流程：  客户端发起页面请求 服务端查询数据并使用相应的模板引擎渲染成 HTML 片段 客户端收到返回 HTML 解析成可见网页内容   优点：  友好的 SEO，每个页面都是服务端返回的完整的 HTML 首屏加载快，页面由后端渲染完成  缺点：  前后端耦合严重，前后端开发相互依赖 交互体验不佳，每个路由都需要页面刷新 服务端负载压力大，渲染任务都由服务端也丧失了客户端作为天然分布式系统的优势  二、客户端渲染（CSR） 随着前端页面复杂程度加剧和 Web2.0 Ajax 技术的发展，就有了前后端分离概念。以 Anglular 为代表的现代前端框架让这种后端提供接口，前端渲染页面的开发方式得到普及。也让服务端和客户端职责得到了明确的分工，让客户端和服务端各自实现更擅长的事情。 渲染流程：\n 客户端发起请求并接收返回的 HTML 内容 客户端解析网页内容并执行 JS 脚本 JS 利用 Ajax请求后端数据（json/xml） JS 动态将数据渲染在页面中   优点：  前后端分离模式，前端专注于UI，后端专注于逻辑 良好的交互体验，局部进行刷新，可以实现单页应用，预加载等提升页面性能 降低服务器压力，部署比较简单节约服务器成本  缺点：  不利于 SEO，页面数据都是动态生成不利于 SEO 优化 首屏白屏，首次请求几乎空白的 HMTL 页面，TTI受限于数据获取和浏览器渲染的耗时  三、服务端渲染（SSR） 随着单页应用的发展，不友好的 SEO 和首屏渲染白屏等问题亟待解决，于是再次考虑引入服务端渲染。主要逻辑是将 Web1.","title":"React Server Components 介绍"},{"content":"前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。\nWEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：\n本篇文章重点讲的就是上面红色框部分缓存内容。\n认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。\n 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。\n 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：\n第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：\n  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：\n 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n 强缓存：Expires \u0026amp; Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：\n 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。\n Expires 是 HTTP 1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires 头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。\n例如，一个文件的 Expires 值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。 所以，Expires 是优化中最理想的情况，因为它根本不会产生请求，所以后端也就无需考虑查询快慢。它的缓存原理，如下：\n  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Expires 的 header，如：   浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；\n  浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行；\n  如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新；\n  Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如：随意修改下客户端时间，就能影响缓存命中的结果。所以在 HTTP 1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：\n  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Cache-Control 的 header，如：   浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；\n  浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；\n  如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新；\n  Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。 这两个 header 可以只启用一个，也可以同时启用，当 response header中，Expires 和 Cache-Control 同时存在时，Cache-Control优先级高于 Expires： 此外，还可以为 Cache-Control 指定 public 或 private 标记。如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。对于 public，则允许所有服务器缓存该资源。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），Cache-Control 默认设为 public 是合理的。\n协商缓存：Last-Modified \u0026amp; Etag 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为304并且会显示一个 Not Modified 的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的： 查看单个请求的 Response Header，也能看到304的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：  协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。\n  【Last-Modified，If-Modified-Since】的控制缓存的原理，如下：  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：  浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：   服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回304时的 response header：   浏览器收到304的响应后，就会从缓存中加载资源。\n  如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。\n  【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：   浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：   浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值：   服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：   浏览器收到304的响应后，就会从缓存中加载资源。\n  Etag 和 Last-Modified 非常相似，都是用来判断一个参数，从而决定是否启用缓存。但是 ETag 相对于 Last-Modified 也有其优势，可以更加准确的判断文件内容是否被修改，从而在实际操作中实用程度也更高。 协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache: 如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。 【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：\n 分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败； 分布式系统尽量关闭掉 ETag (每台机器生成的 ETag 都会不一样）；\n 比如，京东页面的资源请求，返回的 repsonse header 就只有 Last-Modified，没有 ETag： 协商缓存需要配合强缓存使用，上面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。\n缓存判断流程 如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下： 总结 最后整理下 http 缓存及其优先级。\n  强缓存和协商缓存同时存在，如果强缓存还在生效期则强制缓存覆盖协商缓存，协商缓存不生效；如果强缓存不在有效期，协商缓存生效。即：强缓存优先级 \u0026gt; 协商缓存优先级\n  强缓存 Expires 和 Cache-Control 同时存在时，则 Cache-Control 会覆盖 Expires，Expires 无论有没有过期，都无效。 即：Cache-Control 优先级 \u0026gt; Expires 优先级。\n  协商缓存 Etag 和 Last-Modified 同时存在时，则 Etag 会覆盖 Last-Modified，Last-Modified 不会生效。即：ETag 优先级 \u0026gt; Last-Modified 优先级。\n  当然还有一种缓存pragma，和 Cache-Control 类似，前者是http1.0内容后者是http1.1内容，并且pragma优先级 \u0026gt; Cache-Control 优先级，不过前者目前基本不使用。\n","permalink":"https://www.xieluping.cn/post/browser-cache/","summary":"前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。\nWEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：\n本篇文章重点讲的就是上面红色框部分缓存内容。\n认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。\n 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。\n 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：\n第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：\n  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：\n 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n 强缓存：Expires \u0026amp; Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：","title":"浏览器缓存机制"},{"content":"js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。\nFirst 首先来看下面一段代码：\nconsole.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); Promise.resolve().then(function() { console.log(\u0026#39;promise1\u0026#39;); }).then(function() { console.log(\u0026#39;promise2\u0026#39;); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'\n执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：\nfunction a() { console.log(\u0026#39;a\u0026#39;); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?\nconsole.log(\u0026#34;sync\u0026#34;); $.on(\u0026#39;button\u0026#39;, \u0026#39;click\u0026#39;, function onClick() { setTimeout(function timer() { console.log(\u0026#39;You clicked the button!\u0026#39;); }, 2000); }); setTimeout(function timeout() { console.log(\u0026#34;Click the button!\u0026#34;); }, 5000); 当浏览器在执行栈执行的时候，发现有异步任务之后，会交给 webapi 去维护，而执行栈则继续执行后面的任务 同样，setTimeout 同样会被添加到 webapi 中 当上面的setTimeout执行结束后并不是直接进入执行栈，而是进入任务队列，等待执行栈为空，setTimeout的可执行函数，被从回调队列中取出，放入了执行栈执行。这个过程就叫做事件循环。\n 推荐个JS执行的可视化工具 loupe\n 任务队列 回头再介绍下任务队列，上面的例子中 webapi 处理完 setTimeout 后，就会直接将回调函数放入任务队列中，等待执行。这个过程必须等待执行栈为空已经前面的任务执行完。例如：\nconsole.log(1) // snippet1 setTimeout(function() { // snippet2  console.log(2); }, 100) setTimeout(function() { // snippet3  console.log(3); setTimeout(function() { // snippet4  console.log(4) }, 0) }, 0) console.log(5) // snippet5 // let start = +new Date; // while(start + 2000 \u0026gt; +new Date){} 这段代码的输出顺序是1, 5, 3, 4, 2。 这段代码的执行过程是：\n snippet1 push 到执行栈，执行完并清空执行栈 snippet2 交给 Web Apis，100ms 后将回调 push 到任务队列 snippet3 交给 Web Apis，0ms 后将回调 push 到任务队列 snippet5 的回调 push 到执行栈，执行完并清空执行栈 snippet3 的回调 push 到执行栈，执行完并清空执行栈，同时将 snippet4 交给 Web Apis，0ms 后将回调 push 到任务队列 snippet4 的回调 push 到执行栈，执行完并清空执行栈 如果 snippet2 已经在任务队列中，将 snippet2 的回调 push 到执行栈，执行完并清空执行栈  任务 以上说的其实都是所谓的“宏任务”，主要包括整体代码 script，setTimeout，setInterval。\n微任务 如果将之前的代码改下：\nconsole.log(1) // snippet1 Promise.resolve().then(function() { // snippet2  console.log(2); }) setTimeout(function() { // snippet3  console.log(3); setTimeout(function() { // snippet4  console.log(4) }, 0) }, 0) console.log(5) // snippet5 这段代码的输出顺序是1, 5, 2, 3, 4。 这是因为 promise 的 then 方法，被认为是在微任务队列当中。 microtask 通常来说就是需要在当前 task 执行结束后立即执行的任务，例如需要对一系列的任务做出回应，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。microtask 任务队列是一个与 task 任务队列相互独立的队列，microtask 任务将会在每一个 task 任务执行结束之后执行。每一个 task 中产生的 microtask 都将会添加到 microtask 队列中，microtask 中产生的 microtask 将会添加至当前队列的尾部，并且 microtask 会按序的处理完队列中的所有任务。microtask 类型的任务目前包括了 MutationObserver 以及 Promise 的回调函数和 node 中的 process.nextTick。\n这段代码的执行过程是：\n snippet1 push 到执行栈，执行完并清空执行栈 snippet2 的回调 push 到 microtask 队列中 snippet3 交给 Web Apis，0ms 后将回调 push 到 marcotask 队列 snippet5 的回调 push 到执行栈，执行完并清空执行栈 script task 执行完后，将 snippet2 中的回调从 microtask 队列取出，push 到执行栈，执行完并清空执行栈 snippet3 的回调 push 到执行栈，执行完并清空执行栈，同时将 snippet4 交给 Web Apis，0ms 后将回调 push 到任务队列 snippet4 的回调 push 到执行栈，执行完并清空执行栈  One more question 如果有下面一段代码：\n\u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; var outer = document.querySelector(\u0026#39;.outer\u0026#39;); var inner = document.querySelector(\u0026#39;.inner\u0026#39;); new MutationObserver(function() { console.log(\u0026#39;mutate\u0026#39;); }).observe(outer, { attributes: true }); function onClick() { console.log(\u0026#39;click\u0026#39;); setTimeout(function() { console.log(\u0026#39;timeout\u0026#39;); }, 0); Promise.resolve().then(function() { console.log(\u0026#39;promise\u0026#39;); }); outer.setAttribute(\u0026#39;data-random\u0026#39;, Math.random()); } inner.addEventListener(\u0026#39;click\u0026#39;, onClick); outer.addEventListener(\u0026#39;click\u0026#39;, onClick); // inner.click(); 在这里不同的浏览器可能会有不同的结果。\n   Chrome FireFox Safari Edge     click click click click   promise mutate mutate click   mutate click click mutate   click mutate mutate timeout   promise timeout promise promise   mutate promise promise timeout   timeout promise timeout promise   timeout timeout timeout     按照上面的推导 Chrome 的输出是正确的。\n 通过上面的例子可以测试出，FireFox 和 Safari 能够正确的执行 microtask 队列，这一点可以通过 MutationObserver 的表现中看出，不过 Promise 被添加至事件队列中的方式好像有些不同。 这一点也是能够理解的，由于 jobs 和 microtasks 的关系以及概念目前还比较模糊，不过人们都普遍的期望他们都能够在两个事件监听器之间执行。这里有 FireFox 和 Safari 的 BUG 记录。（目前 Safari 已经修复了这一 BUG） 在 Edge 中我们可以明显的看出其压入 Promise 的方式是错误的，同时其执行 microtask 队列的方式也不正确，它没有在两个事件监听器之间执行，反而是在所有的事件监听器之后执行，所以才会只输出了一次 mutate 。Edge bug ticket （目前已修复）\n 加入我们现在取消上段代码中最后一行的注释，使用模拟点击输出的是什么呢？\n   Chrome FireFox Safari Edge     click click click click   click click click click   promise mutate mutate mutate   mutate timeout promise timeout   promise promise promise promise   timeout promise timeout timeout   timeout timeout timeout promise    在确定上面答案前先看一个小例子：\n\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;click me\u0026lt;/button\u0026gt; let btn = document.getElementById(\u0026#39;btn\u0026#39;); console.log(1); btn.onclick = function() { console.log(2) } console.log(3); 很明显输出顺序是：1, 3, 2。 但是如果是直接调用 click 方法：\nlet btn = document.getElementById(\u0026#39;btn\u0026#39;); console.log(1); btn.onclick = function() { console.log(2) } btn.click(); console.log(3); 输出的结果是：1, 2, 3。 原因是我们调用 .click()，使得事件监听器的回调函数和当前运行的脚本同步执行而不再是异步。\n同理在之前的例子中由于我们调用 click()，使得事件监听器的回调函数和当前运行的脚本同步执行，所以当前脚本的执行栈会一直压在 JS 执行栈当中（简单来说就是click的回调并没有加入任务队列中，而是直接执行了）。所以在这个 demo 中 microtask 不会在每一个 click 事件之后执行，而是在两个 click 事件执行完成之后执行。所以在这里我们可以再次的对 microtask 的检查点进行定义：当执行栈(JS Stack)为空时，执行一次 microtask 检查点。这也确保了无论是一个 task 还是一个 microtask 在执行完毕之后都会生成一个 microtask 检查点，也保证了 microtask 队列能够一次性执行完毕。\n","permalink":"https://www.xieluping.cn/post/event-loop/","summary":"js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。\nFirst 首先来看下面一段代码：\nconsole.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); Promise.resolve().then(function() { console.log(\u0026#39;promise1\u0026#39;); }).then(function() { console.log(\u0026#39;promise2\u0026#39;); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'\n执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：\nfunction a() { console.log(\u0026#39;a\u0026#39;); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?\nconsole.log(\u0026#34;sync\u0026#34;); $.on(\u0026#39;button\u0026#39;, \u0026#39;click\u0026#39;, function onClick() { setTimeout(function timer() { console.log(\u0026#39;You clicked the button!\u0026#39;); }, 2000); }); setTimeout(function timeout() { console.log(\u0026#34;Click the button!","title":"JavaScript 任务和事件循环"},{"content":"instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 \u0026ldquo;object\u0026rdquo;。例如：\nvar arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：\nvar arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ? console.log( String instanceof String ); console.log( Function instanceof Function ); console.log( Function instanceof Object ); console.log( Object instanceof Function ); console.log( Object instanceof Object ); 要解释这个问题就需要了解 1.JavaScript 语言规范中是如何定义 instanceof 运算符的，2.JavaScript 原型继承机制。\ninstanceof 运算符的定义 在 ECMAScript-262 中 instanceof 运算符的定义是这样的:\n 12.9.4 Runtime Semantics: InstanceofOperator(O, C) The abstract operation InstanceofOperator(O, C) implements the generic algorithm for determining if an object O inherits from the inheritance path defined by constructor C. This abstract operation performs the following steps:\n If Type(C) is not Object, throw a TypeError exception. Let instOfHandler be GetMethod(C,@@hasInstance). ReturnIfAbrupt(instOfHandler). If instOfHandler is not undefined, then a. Return ToBoolean(Call(instOfHandler, C, «O»)). If IsCallable(C) is false, throw a TypeError exception. Return OrdinaryHasInstance(C, O). NOTE Steps 5 and 6 provide compatibility with previous editions of ECMAScript that did not use a @@hasInstance method to define the instanceof operator semantics. If a function object does not define or inherit @@hasInstance it uses the default instanceof semantics.    7.3.19 OrdinaryHasInstance (C, O) The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object O inherits from the instance object inheritance path provided by constructor C. This abstract operation performs the following steps:\n If IsCallable(C) is false, return false. If C has a [[BoundTargetFunction]] internal slot, then a. Let BC be the value of C’s [[BoundTargetFunction]] internal slot. b. Return InstanceofOperator(O,BC) (see 12.9.4). If Type(O) is not Object, return false. Let P be Get(C, \u0026ldquo;prototype\u0026rdquo;). ReturnIfAbrupt(P). If Type(P) is not Object, throw a TypeError exception. Repeat a. Let O be O.[[GetPrototypeOf]](). b. ReturnIfAbrupt(O). c. If O is null, return false. d. If SameValue(P, O) is true, return true.   官网的定义非常晦涩，上面的翻译成代码大概就是：\nfunction instanceOf( L, R ) { //L 表示左表达式，R 表示右表达式  var P = R.prototype; // 取 R 的显示原型  L = L.__proto__; // 取 L 的隐式原型  while ( true ) { if ( L === null ) return false; if ( P === L ) return true; L = L.__proto__; } } 再直接点的表达就是 instanceof 会一直在 obj 的原型链上查找，直到找到右边那个构造函数的 prototype 属性，或者为 null 的时候才停止。 类似：\nobj.__proto__.__proto__ ... = Obj.prototype obj 会一直沿着隐式原型链 __proto__ 向上查找直到 obj.__proto__.__proto__ ...... === Obj.prototype 为止，如果找到则返回 true，也就是 obj 为 Obj 的一个实例。否则返回 false，obj 不是 Obj 的实例。\nJavaScript 原型继承机制 原型与原型链 在 JavaScript 每个函数都有一个 prototype 属性，该属性存储的就是原型对象。JavaScript 构造函数的继承都是通过 prototype 属性， 真正的原型链的实现是通过 __proto__ 实现的，__proto__其实是指向‘父类’的 prototype 属性。例如：\nvar Foo = function() {} var foo = new Foo; console.log(foo.__proto__ === Foo.prototype) // true console.log(Foo.__proto__ === Function.prototype) // true 原型继承 JavaScript 是单继承的，Object.prototype 是原型链的顶端，所有对象从它继承了包括 valueOf、toString 等等方法和属性。Object 本身是构造函数，继承了 Function.prototype。 Function 也是对象，继承了 Object.prototype。\n下面我们推导下之前的两个例子，其他的可以自行推倒。\n Object instanceof Object  ObjectL = Object, ObjectR = Object; R = ObjectR.prototype = Object.prototype L = ObjectL.__proto__ = Function.prototype R != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype R == L // 返回 true  String instanceof String  StringL = String, StringR = String; R = StringR.prototype = String.prototype L = StringL.__proto__ = Function.prototype R != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype R != L // 接着查找 L = Object.prototype.__proto__ = null // 返回 false 一切皆对象？ 常常说 JavaScript 中一切皆对象，那么就有这样一个问题了：\n\u0026#39;string\u0026#39;.__proto__ === String.prototype // true \u0026#39;string\u0026#39; instanceof String // false 按照上面的推导，'string' instanceof String 应该为 true，但是我们得到的却是 false。 其实问题的关键在于：\nconsole.log(typeof \u0026#39;string\u0026#39;); // string \u0026lsquo;string\u0026rsquo; 并不是一个 object 对象，MDN 上对 instanceof 的定义是：\n The instanceof operator tests whether an object in its prototype chain has the prototype property of a constructor.\n 这样又有一个问题了，既然字符串不是对象那为什么有对象才有的属性和方法呢？\nvar s1 = \u0026#34;string\u0026#34;; var s2 = s1.substring(2); 为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型: Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。\n《JavaScript高级程序设计》中是这么解释的：\n 上面的例子其实当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成： (1) 创建 String 类型的一个实例; (2) 在实例上调用指定的方法; (3) 销毁这个实例。\n 可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。\nvar s1 = new String(\u0026#34;some text\u0026#34;); var s2 = s1.substring(2); s1 = null; 《Javascript权威指南》里说：\n 其实（包装对象）在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样的。\n 这样 Boolean、Number 是一样的逻辑。还剩下两种基本类型：null 和 undefined。\nundefined 当我们对变量只声明没有初始化时，输出为 undefined，typeof undefined 返回的是 undefined 也不是 object 类型，所以 undefined 并不是任何对象的实例。\nnull 表示的是空对象，虽然 typeof null 是 object，但是 null 和 undefined 一样并没有任何属性和方法，在 instanceof 定义中也有判断，如果类型不是 object（这个类型判断并不是跟 typeof 返回值一样），就返回 false。 ","permalink":"https://www.xieluping.cn/post/instanceof/","summary":"instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 \u0026ldquo;object\u0026rdquo;。例如：\nvar arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：\nvar arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ?","title":"JavaScript instanceof 操作符"},{"content":"服务端 1. 获取 access_token access_token 是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用 access_token。通过get请求 https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential\u0026amp;appid=APPID\u0026amp;secret=APPSECRET ，正常返回：\n{ \u0026#34;access_token\u0026#34;: \u0026#34;ACCESS_TOKEN\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200 } 2. 获取 jsapi_ticket api_ticket 是用于调用微信卡券 JS API 的临时票据，需要通过 access_token 来获取，api_ticket 和 accss_token 一样有效期都为7200s。由于获取api_ticket 的api 调用次数非常有限，频繁刷新 api_ticket 会导致 api 调用受限，影响自身业务，开发者需在自己的服务存储与更新 api_ticket。 通过 get 请求 https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN\u0026amp;type=wx_card ，正常返回：\n{ \u0026#34;errcode\u0026#34;: 0, \u0026#34;errmsg\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;ticket\u0026#34;: \u0026#34;bxLdikRXVbTPdHSM05e5u5sUoXNKdvsdshFKA\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200 } 3. 生成 signature 需要将 noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）进行sha1签名得到signature。对所有待签名参数按照字段名的 ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1\u0026amp;key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对 string1 作 sha1 加密，字段名和字段值都采用原始值，不进行 URL 转义。\n字符串 string1：\njsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg\u0026amp;noncestr=Wm3WZYTPz0wzccnW\u0026amp;timestamp=1414587457\u0026amp;url=http://mp.weixin.qq.com?params=value 然后对 string1 进行签名后即可得到 signature, 类似：\n0f9de62fce790f9a083d5c99e95740ceb90c27ed 最后将分享需要的权限验证配置项：appId， timestamp，nonceStr， signature 返回即可。\n 推荐能用到的库 sha1、redis、request，具体使用参考 http://npmjs.com\n 客户端 1. 修改 JS 接口安全域名 即使客户端其他设置都完成后，域名也是备案好的，但是还是经常会发生分享不成功的情况，打开 debug 模式后，显示的信息是 { \u0026quot;errMsg\u0026quot;: \u0026quot;config:invalid url domain\u0026quot; }，很大程度上是因为公众号后台配置错误，注意上面说的是域名不是 url， 所以不需要加上协议头！！！\n2. 引入 jssdk 在需要调用JS接口的页面引入如下JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.2.0.js 如果需要动态引入的话可以参照：\n(function(id, d, s, cb) { var d = d || window.document, s = s || \u0026#39;script\u0026#39;, fjs = d.getElementsByTagName(s)[0], js; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = \u0026#39;//res.wx.qq.com/open/js/jweixin-1.2.0.js\u0026#39;; fjs.parentNode.insertBefore(js, fjs); cb \u0026amp;\u0026amp; cb(); }(\u0026#39;wx-jssdk\u0026#39;)); 3. 配置分享 首先需要调用后端接口获取配置项，一定要带上当前 url (不带不包含#及其后面部分)！！！否则不能成功分享。 例如：\n$.ajax({ url: \u0026#39;/server/getConfig/?url=\u0026#39;+ location.href.split(\u0026#39;#\u0026#39;)[0], type: \u0026#39;GET\u0026#39;, ... }) 配置完 wx.config 后需要在 wx.ready 回调中设置分享接口，可以设置多个分享具体参考官方文档 https://mp.weixin.qq.com/wiki?t=resource/res_main\u0026amp;id=mp1421141115\n 最后说下分享的图片必须是 https 协议的，否则不会展示\n ","permalink":"https://www.xieluping.cn/post/wx-share/","summary":"服务端 1. 获取 access_token access_token 是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用 access_token。通过get请求 https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential\u0026amp;appid=APPID\u0026amp;secret=APPSECRET ，正常返回：\n{ \u0026#34;access_token\u0026#34;: \u0026#34;ACCESS_TOKEN\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200 } 2. 获取 jsapi_ticket api_ticket 是用于调用微信卡券 JS API 的临时票据，需要通过 access_token 来获取，api_ticket 和 accss_token 一样有效期都为7200s。由于获取api_ticket 的api 调用次数非常有限，频繁刷新 api_ticket 会导致 api 调用受限，影响自身业务，开发者需在自己的服务存储与更新 api_ticket。 通过 get 请求 https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN\u0026amp;type=wx_card ，正常返回：\n{ \u0026#34;errcode\u0026#34;: 0, \u0026#34;errmsg\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;ticket\u0026#34;: \u0026#34;bxLdikRXVbTPdHSM05e5u5sUoXNKdvsdshFKA\u0026#34;, \u0026#34;expires_in\u0026#34;: 7200 } 3. 生成 signature 需要将 noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）进行sha1签名得到signature。对所有待签名参数按照字段名的 ASCII 码从小到大排序（字典序）后，使用URL键值对的格式（即key1=value1\u0026amp;key2=value2…）拼接成字符串string1。这里需要注意的是所有参数名均为小写字符。对 string1 作 sha1 加密，字段名和字段值都采用原始值，不进行 URL 转义。\n字符串 string1：\njsapi_ticket=sM4AOVdWfPE4DxkXGEs8VMCPGGVi4C3VM0P37wVUCFvkVAy_90u5h9nbSlYy3-Sl-HhTdfl2fzFy1AOcHKP7qg\u0026amp;noncestr=Wm3WZYTPz0wzccnW\u0026amp;timestamp=1414587457\u0026amp;url=http://mp.weixin.qq.com?params=value 然后对 string1 进行签名后即可得到 signature, 类似：","title":"微信 jssdk 分享"},{"content":"什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。\n为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：\n共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。\njs代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.name = \u0026#34;hello world\u0026#34;; }).directive(\u0026#34;shareDirective\u0026#34;, function () { return { template: \u0026#39;Say:{{name}}\u0026#39; } }); html代码:\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div share-directive=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 输出结果：\nSay:hello world 隔离 scope 使用隔离 scope 的时候，无法从父 scope 中共享属性。因此下面示例无法输出父 scope 中定义的 name 属性值。\njs代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.name = \u0026#34;hello world\u0026#34;; }).directive(\u0026#34;isolatedDirective\u0026#34;, function () { return { scope: {}, template: \u0026#39;Say:{{name}}\u0026#39; } }); html代码：\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div isolated-directive=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 输出结果：\nSay: 从上图可以看出共享 scope 允许从父 scope 渗入到 directive 中，而隔离 scope 不能，在隔离 scope 下，给 directive 创造了一堵墙，使得父 scope 无法渗入到 directive 中。\n具体文档可以参考：https://docs.angularjs.org/guide/directive#isolating-the-scope-of-a-directive\n如何在 directive 中创建隔离 scope 在 Directive 中创建隔离 scope 很简单，只需要定义一个 scope 属性即可，这样，这个 directive 的 scope 将会创建一个新的 scope，如果多个 directive 定义在同一个元素上，只会创建一个新的 scope。\nangular.module(\u0026#39;app\u0026#39;).controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.user = { id:1, name:\u0026#34;hello world\u0026#34; }; }).directive(\u0026#39;isolatedScope\u0026#39;, function () { return { scope: {}, template: \u0026#39;Name: {{user.name}} Street: {{user.addr}}\u0026#39; }; }); 现在 scope 是隔离的，user 对象将无法从父 scope 中访问，因此，在 directive 渲染的时候 user 对象的占位将不会输出内容。\n隔离 scope 和父 scope 如何交互 directive 在使用隔离 scope 的时候，提供了三种方法同隔离之外的地方交互。这三种分别是:\n @ 绑定一个局部 scope 属性到当前 dom 节点的属性值。结果总是一个字符串，因为 dom 属性是字符串。 \u0026amp; 提供一种方式执行一个表达式在父 scope 的上下文中。如果没有指定 attr 名称，则属性名称为相同的本地名称。 = 通过 directive 的 attr 属性的值在局部 scope 的属性和父 scope 属性名之间建立双向绑定。  @ 局部 scope 属性 @ 方式局部属性用来访问 directive 外部环境定义的字符串值，主要是通过 directive 所在的标签属性绑定外部字符串值。这种绑定是单向的，即父 scope 的绑定变化，directive 中的 scope 的属性会同步变化，而隔离 scope 中的绑定变化，父 scope 是不知道的。\n如下示例：directive 声明未隔离 scope 类型，并且使用@绑定 name 属性，在 directive 中使用 name 属性绑定父 scope 中的属性。当改变父 scope 中属性的值的时候，directive 会同步更新值，当改变 directive 的 scope 的属性值时，父 scope 无法同步更新值。\njs 代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.name = \u0026#34;hello world\u0026#34;; }).directive(\u0026#34;isolatedDirective\u0026#34;, function () { return { scope: { name: \u0026#34;@\u0026#34; }, template: \u0026#39;Say：{{name}} \u0026lt;br\u0026gt;改变隔离scope的name：\u0026lt;input type=\u0026#34;buttom\u0026#34; value=\u0026#34;\u0026#34; ng-model=\u0026#34;name\u0026#34; class=\u0026#34;ng-pristine ng-valid\u0026#34;\u0026gt;\u0026#39; } }) html 代码：\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;result\u0026#34;\u0026gt; \u0026lt;div\u0026gt;父scope： \u0026lt;div\u0026gt;Say：{{name}}\u0026lt;br\u0026gt;改变父scope的name：\u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34; ng-model=\u0026#34;name\u0026#34;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;隔离scope： \u0026lt;div isolated-directive name=\u0026#34;{{name}}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;隔离scope（不使用{{name}}）： \u0026lt;div isolated-directive name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; = 局部 scope 属性 = 通过 directive 的 attr 属性的值在局部 scope 的属性和父 scope 属性名之间建立双向绑定。 意思是，当你想要一个双向绑定的属性的时候，你可以使用=来引入外部属性。无论是改变父 scope 还是隔离 scope 里的属性，父 scope 和隔离 scope 都会同时更新属性值，因为它们是双向绑定的关系。\njs 代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.user = { name: \u0026#39;hello\u0026#39;, id: 1 }; }).directive(\u0026#34;isolatedDirective\u0026#34;, function () { return { scope: { user: \u0026#34;=\u0026#34; }, template: \u0026#39;Say：{{user.name}} \u0026lt;br\u0026gt;改变隔离scope的name：\u0026lt;input type=\u0026#34;buttom\u0026#34; value=\u0026#34;\u0026#34; ng-model=\u0026#34;user.name\u0026#34;/\u0026gt;\u0026#39; } }) html 代码：\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div\u0026gt;父scope： \u0026lt;div\u0026gt;Say：{{user.name}}\u0026lt;br\u0026gt;改变父scope的name：\u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34; ng-model=\u0026#34;user.name\u0026#34;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;隔离scope： \u0026lt;div isolated-directive user=\u0026#34;user\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;隔离scope（使用{{name}}）： \u0026lt;div isolated-directive user=\u0026#34;{{user}}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026amp; 局部 scope 属性 \u0026amp; 方式提供一种途经是 directive 能在父 scope 的上下文中执行一个表达式。此表达式可以是一个 function。 比如当你写了一个 directive，当用户点击按钮时，directive 想要通知 controller，controller 无法知道 directive 中发生了什么，也许你可以通过使用 angular 中的 event 广播来做到，但是必须要在 controller 中增加一个事件监听方法。 最好的方法就是让 directive 可以通过一个父 scope 中的 function，当 directive 中有什么动作需要更新到父 scope 中的时候，可以在父 scope 上下文中执行一段代码或者一个函数。\n如下示例在 directive 中执行父 scope 的 function。\njs代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.value = \u0026#34;hello world\u0026#34;; $scope.click = function () { $scope.value = Math.random(); }; }).directive(\u0026#34;isolatedDirective\u0026#34;, function () { return { scope: { action: \u0026#34;\u0026amp;\u0026#34; }, template: \u0026#39;\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;在directive中执行父scope定义的方法\u0026#34; ng-click=\u0026#34;action()\u0026#34;/\u0026gt;\u0026#39; } }) html 代码：\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div\u0026gt;父scope： \u0026lt;div\u0026gt;Say：{{value}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;隔离scope： \u0026lt;div isolated-directive action=\u0026#34;click()\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 以上内容转自：https://blog.coding.net/blog/angularjs-directive-isolate-scope\n小结 相信关于隔离 scope 和父 scope 如何交互的三种方法已经介绍得非常清楚了，最后发现stackoverflow上面有个更加简单直接的解释，原文如下：\nAll three bindings are ways of passing data from your parent scope to your directive\u0026rsquo;s isolated scope through the element\u0026rsquo;s attributes:\n  @ binding is for passing strings. These strings support {{}} expressions for interpolated values. For example: . The interpolated expression is evaluated against directive\u0026rsquo;s parent scope.    = binding is for two-way model binding. The model in parent scope is linked to the model in the directive\u0026rsquo;s isolated scope. Changes to one model affects the other, and vice versa.    \u0026amp; binding is for passing a method into your directive\u0026rsquo;s scope so that it can be called within your directive. The method is pre-bound to the directive\u0026rsquo;s parent scope, and supports arguments. For example if the method is hello(name) in parent scope, then in order to execute the method from inside your directive, you must call $scope.hello({name:\u0026lsquo;world\u0026rsquo;})   I find that it\u0026rsquo;s easier to remember these differences by referring to the scope bindings by a shorter description:\n @ Attribute string binding = Two-way model binding \u0026amp; Callback method binding  The symbols also make it clearer as to what the scope variable represents inside of your directive\u0026rsquo;s implementation:\n @ string = model \u0026amp; method  In order of usefulness (for me anyways):\n = @ \u0026amp;  更多请参考API文档：https://docs.angularjs.org/api/ng/service/$compile 。\n","permalink":"https://www.xieluping.cn/post/ng-scope/","summary":"什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。\n为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：\n共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。\njs代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.name = \u0026#34;hello world\u0026#34;; }).directive(\u0026#34;shareDirective\u0026#34;, function () { return { template: \u0026#39;Say:{{name}}\u0026#39; } }); html代码:\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div share-directive=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 输出结果：","title":"AngularJS Directive 隔离 Scope 数据交互"},{"content":"","permalink":"https://www.xieluping.cn/tags/","summary":"tags","title":"Tags"}]