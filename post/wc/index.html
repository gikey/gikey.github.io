<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>基于 Web Components 跨框架组件开发 | Null</title>
<meta name=keywords content>
<meta name=description content="什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：
 Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：
 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define('my-element', WordCount, { extends: 'p' }); custom elements 可以分为两种：
 Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(&#34;my-element&#34;)。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称<p is=&#34;my-element&#34;>, 或者 document.createElement(&#34;p&#34;, { is: &#34;my-element&#34; })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   <my-element name=&#34;web component&#34;></my-element > <script> class MyElement extends HTMLElement { connectedCallback() { const shadow = this.">
<meta name=author content>
<link rel=canonical href=https://gikey.github.io/post/wc/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gikey.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://gikey.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://gikey.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://gikey.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://gikey.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<link rel=stylesheet href=https://gikey.github.io/css/style.css><meta property="og:title" content="基于 Web Components 跨框架组件开发">
<meta property="og:description" content="什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：
 Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：
 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define('my-element', WordCount, { extends: 'p' }); custom elements 可以分为两种：
 Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(&#34;my-element&#34;)。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称<p is=&#34;my-element&#34;>, 或者 document.createElement(&#34;p&#34;, { is: &#34;my-element&#34; })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   <my-element name=&#34;web component&#34;></my-element > <script> class MyElement extends HTMLElement { connectedCallback() { const shadow = this.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://gikey.github.io/post/wc/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2021-08-18T11:55:12+08:00">
<meta property="article:modified_time" content="2021-08-18T11:55:12+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="基于 Web Components 跨框架组件开发">
<meta name=twitter:description content="什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：
 Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：
 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define('my-element', WordCount, { extends: 'p' }); custom elements 可以分为两种：
 Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(&#34;my-element&#34;)。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称<p is=&#34;my-element&#34;>, 或者 document.createElement(&#34;p&#34;, { is: &#34;my-element&#34; })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   <my-element name=&#34;web component&#34;></my-element > <script> class MyElement extends HTMLElement { connectedCallback() { const shadow = this.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://gikey.github.io/post/"},{"@type":"ListItem","position":3,"name":"基于 Web Components 跨框架组件开发","item":"https://gikey.github.io/post/wc/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"基于 Web Components 跨框架组件开发","name":"基于 Web Components 跨框架组件开发","description":"什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：\n Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：\n 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define(\u0026#39;my-element\u0026#39;, WordCount, { extends: \u0026#39;p\u0026#39; }); custom elements 可以分为两种：\n Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(\u0026quot;my-element\u0026quot;)。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称\u0026lt;p is=\u0026quot;my-element\u0026quot;\u0026gt;, 或者 document.createElement(\u0026quot;p\u0026quot;, { is: \u0026quot;my-element\u0026quot; })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   \u0026lt;my-element name=\u0026#34;web component\u0026#34;\u0026gt;\u0026lt;/my-element \u0026gt; \u0026lt;script\u0026gt; class MyElement extends HTMLElement { connectedCallback() { const shadow = this.","keywords":[],"articleBody":"什么是 Web Components Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：\n Custom Elements：带有特定行为且用户自命名的 HTML 元素 Shadow DOM：对标签和样式的一层 DOM 包装 HTML Templates：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口  Custom Elements Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：\n 表示所创建的元素名称的符合 DOMString 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。 用于定义元素行为的类 。 可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。  customElements.define('my-element', WordCount, { extends: 'p' }); custom elements 可以分为两种：\n Autonomous custom elements 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：document.createElement(\"my-element\")。 Customized built-in elements 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称, 或者 document.createElement(\"p\", { is: \"my-element\" })。   Shadow DOM Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。   Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM内部的DOM树。 Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。 Shadow root: Shadow tree的根节点。   my-element name=\"web component\"my-element  script class MyElement extends HTMLElement { connectedCallback() { const shadow = this.attachShadow({mode: 'open'}); shadow.innerHTML = ` Hello, ${this.getAttribute('name')}`; } } window.customElements.define('my-element', MyElement); script HTML Templates  是一种 HTML 元素，所以一个含内容的模板所具备的最基本形式如下：\ntemplate h1Hello worldh1 template 在浏览器中运行这段代码会显示空白页面，因为浏览器并没有渲染模板元素内容。这种方式的强大之处在于它允许我们保存自定义内容（或内容结构），以供后续使用，而不需要使用 JavaScript 来动态编写 HTML 代码。 模板可以包含任意 HTML，包括脚本和样式元素。例如：\ntemplate id=\"template\" script const button = document.getElementById('click-me'); button.addEventListener('click', event = alert(event)); script style #click-me { all: unset; background: tomato; border: 0; border-radius: 4px; color: white; font-family: Helvetica; font-size: 1.5rem; padding: .5rem 1rem; } style button id=\"click-me\"Log click eventbutton template  使用与 Vue 的用法基本一模一样\n pslot name=\"my-text\"My default textslotp my-element span slot=\"my-text\"Let's have some different text!span my-element 生命周期  constructor：组件被 create 的时候会被调用，整个生命周期中最早触发也只会触发一次，通常可以在这里做一些初始化私有变量、记录数据的一些操作；但是出于性能和职责分离的考虑，不建议在这里做一些 DOM 相关的事情。 connectedCallback：组件被连接到 DOM Tree 的时候会触发，这个时机包括节点被插入节点树、节点被从节点树中移动，所以它可能会被触发多次。 disconnectedCallback：组件被从 DOM Tree 中移除的时候触发。 adoptedCallback：当 custom element被移动到新的文档时，被调用。adoptNode attributeChangedCallback：当组件的 attribute 发生变化的时候触发，它的三个形参分别是 name, oldValue, newValue，如果声明了 properties 对象，对 attribute 的相应值变化也会触发这个回调。需要注意的是，如果覆盖了组件的 observedAttributes 静态方法，properties 对象中声明的值不会触发，它会按照覆盖的 observedAttributes 静态方法的返回值为准。  class MyComponent extends HTMLElement { constructor() { super() } connectedCallback(){ // 当自定义元素第一次被连接到文档DOM时被调用  } disconnectedCallback(){ // 当自定义元素与文档DOM断开连接时被调用  } adoptedCallback(){ // 当自定义元素被移动到新文档时被调用  } attributeChangedCallback(){ // 当自定义元素的一个属性被增加、移除或更改时被调用  } } 组件通信 父组件传递数据给子组件  通过 DOM 属性，不支持复杂对象的传递。  // parentWc const parentTemplate = ``; class ParentWc extends HTMLElement { // ...  connectedCallback() { const child = this.shadowRoot.querySelector('child-wc') child.setAttribute('text', 'web component'); } } window.customElements.define('parent-wc', ParentWc) // childWc class ChildWc extends HTMLElement { // 必须先生命需要监听的属性  static get observedAttributes() { return ['text']; } attributeChangedCallback(name, oldValue, newValue) { if(name==='text' \u0026 oldValue !== newValue) { console.log(newValue) } } } window.customElements.define('child-wc', ChildWc); 第二种方式通过组件实例属性。这是目前主流的传值方式，支持复杂对象的传递。  // parentWc class ParentWc extends HTMLElement { // ...  connectedCallback() { this.shadowRoot.querySelector('child-wc').data.text = { type: 'web component'} } } window.customElements.define('parent-wc', ParentWc) // childWc class ChildWc extends HTMLElement { constructor() { super(); this.data = {text: {type: 'child web component' } } Object.defineProperty(this.data, 'text', { set: value = { console.log(value) } }) } } 子组件传递数据给父组件  第一种通过事件监听，利用原生 CustomEvent 函数来创建自定义事件，然后在子组件实例上派发此事件以及数据，同时父组件进行监听，可以借助 document 设置事件总线，进行跨组件全局通信。  // childWc class ChildWc extends HTMLElement { // ...  connectedCallback() { const event = new CustomEvent('custom-event', { detail: { value: 'child web component' } }); this.dispatchEvent(event); } window.customElements.define('child-wc', ChildWc) // parentWc class ParentWc extends HTMLElement { // ...  connectedCallback() { const child = this.shadowRoot.querySelector('child-wc') child.addEventListener('custom-event', ({ detail }) = { console.log(detail.value); }) } } window.customElements.define('parent-wc', ParentWc) 第二种方式是直接调用父组件方法。  // parentWc class ParentWc extends HTMLElement { // ...  say(msg) { console.log(msg); } } window.customElements.define('parent-wc', ParentWc) class ChildWc extends HTMLElement { // ...  connectedCallback() { this.getRootNode().host.say('child web component') } } window.customElements.define('child-wc', ChildWc) Shadow DOM 样式封装 目前，定义一个 shadow DOM 节点样式的唯一方法就是在 shadow root 的内部 HTML 中添加一个  元素。这种方法几乎在所有情况下都能正常工作，因为浏览器会在可能的情况下对这些组件中的样式表进行重写。在 shadow DOM 中我们可以使用link 或者 @import 引入外部样式，但是必须明确元素样式表的位置。\nslot 节点设定样式 不会移动用户的 Light DOM，中内容依然会在原处，这就意味着可以直接在外层直接设置对应的样式。 style h1 { ... } style my-counter h1 slot=\"title\"Counterh1 my-counter ::slotted 可以在 shadow DOM 中为中节点设置样式，::slotted设置的样式只能在最顶层的节点生效：\n style ::slotted { color: red; } ::slotted(.description) { color: blue; } -- 不生效 -- ::slotted(.lib)， ::slotted(.description .lib) { color: green; } style my-countr h1 slot=\"title\"Counterh1 p class=\"description\" A counter build by span class=\"\u0008lib\"web componentspan p my-counter css 自定义属性 css 自定义属性可以传入 shadow DOM 内部，从而调整内部样式，从概念上看，这与类似， 可以简单理解为：创建“样式占位符”以便进行替换：\n style :root { --primary: red; } style  style div { background-color: var(--primary, blue); } style 可构造的样式表 为了更好地复用样式，可构造的样式表提供了类似于编写普通 CSS 并在多个节点之间共享这些样式的方式。\nconst everythingTomato = new CSSStyleSheet(); everythingTomato.replace('* { color: tomato; }'); document.adoptedStyleSheets = [everythingTomato]; class MyCounter extends HTMLElement { constructor() { super(); this.adoptedStyleSheets = [everythingTomato]; } connectedCallback() { this.shadowRoot.innerHTML = `CSS colors are fun`; } } part 伪元素 ::part 可以结合其他伪类/元素使用，不能再加上选择器\n style tab-element::part(tab) { color: grey; } tab-element::part(tab):hover { color: black; } tab-element::part(active) { color: black; } -- 不生效 -- tab-element::part(tab) span { color: white; } style  template div part=\"tab active\" span part=\"tab\" tab1 span div div part=\"tab\" span tab2 span div template Demo: 实现计数器  html lang=\"en\" head meta charset=\"UTF-8\" / meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" / meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" / titleweb component demotitle style body { display: flex; justify-content: center; padding: 50px; } h1 { font-size: 30px; text-align: center; margin-bottom: 40px; } style head body my-counter h1 slot=\"title\"Counterh1 my-counter template style span { width: 4rem; display: inline-block; text-align: center; } button { width: 4rem; height: 4rem; border: none; border-radius: 10px; background-color: seagreen; color: white; } style slot name=\"title\"slot button id=\"dec\"-button span id=\"count\"span button id=\"inc\"+button template script const template = document.querySelector(\"template\"); class MyCounter extends HTMLElement { constructor() { super(); this.count = 0; this.attachShadow({ mode: \"open\" }); } connectedCallback() { this.shadowRoot.appendChild(template.content.cloneNode(true)); this.shadowRoot.getElementById(\"inc\").onclick = () = this.inc(); this.shadowRoot.getElementById(\"dec\").onclick = () = this.dec(); this.update(this.count); } inc() { this.update(++this.count); } dec() { this.update(--this.count); } update(count) { this.shadowRoot.getElementById(\"count\").innerHTML = count; } } window.customElements.define(\"my-counter\", MyCounter); script body html Live demo: https://webcomponents.dev/edit/Osbw4TzJEizqkd5ZkHOs/www/index.html\n与现代框架对比 https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/\nBundle Size 上面计数器基于各种框架/库实现rollup打包大小如下： 单个组件： 打包30个： Performance 单个页面中 50个 JS 解析+DOM Tree 创建耗时： 开源实现 React/Vue  React 和 Web Components 为了解决不同的问题而生。Web Components 为可复用组件提供了强大的封装，而 React 则提供了声明式的解决方案，使 DOM 与数据保持同步。两者旨在互补。作为开发人员，可以自由选择在 Web Components 中使用 React，或者在 React 中使用 Web Components，或者两者共存。 React 和 Vue 开发 Web Component 的思路基本一样，都是用 Custom Elements 包装对应的 React/Vue 组件，以React 为例：\n import React from 'react'; import ReactDOM from 'react-dom'; export default function defineElement(Component, elementName, observedAttributes = [], events = []) { class CustomElement extends HTMLElement { constructor() { super(); observedAttributes.forEach(property = Object.defineProperty(this, property, { set: value = this.setterProxy(property, value) })); this.events = events; } setterProxy(name, value) { this.attributeChangedCallback(name, value, value); // Careful, this is a bug, since the oldVal always equals the new val  } connectedCallback() { const props = [...this.attributes].reduce((props, attribute) = ({ ...props, [attribute.name]: attribute.value }), { root: this }); const instance = (Component {...(props)} /); this.assignEvents(instance); ReactDOM.render(instance, this); this.instance = instance; this.props = props; } attributeChangedCallback(name, oldValue, newValue) { const { instance } = this; if (!instance) return; const newProps = { ...(this.props), ...({ [name]: newValue }) }; const newInstance = (Component {...(newProps)} /); this.assignEvents(newInstance); ReactDOM.render(newInstance, this); this.instance = newInstance; this.props = newProps; } assignEvents(instance) { this.events.forEach(event = instance.props[event] = eventArgs = this.dispatchEvent(new CustomEvent(event, { detail: eventArgs }))); } } CustomElement.observedAttributes = observedAttributes; window.customElements.define(elementName, CustomElement);  React 基于 bitovi/react-to-webcomponent 实现 React 转换 Web Component； Vue 基于 https://cli.vuejs.org/zh/guide/build-targets.html 设置构建目标为 wc 来产出 Web Component，也可以 https://github.com/vuejs/vue-web-component-wrapper 包装一下（需配合vue-style-loader）\n Lit Lit 是 Google 提供的一组开源库，可帮助开发者构建快速、轻量且适用于任何框架的组件，Lit vs React，上面计数器用Lit实现就变得非常简单：\nimport { LitElement, html, css } from \"lit\"; import { customElement, property } from \"lit/decorators.js\"; @customElement(\"my-counter\") export class MyCounter extends LitElement { static styles = css` div { display: inline-block; text-align: center; font-size: 30px; width: 50px; text-align: center; } button { width: 4rem; height: 4rem; border: none; border-radius: 10px; background-color: seagreen; color: white; font-size: 40px; } `; @state({type: Number}) count: number = 0; render() { return html`  ${() = this.count--}- ${this.count} ${() = this.count++}+ `; } }  “传统框架和 Web Components 结合最大的问题就在于运行时：单独分发的 WC 里面直接打包框架运行时，等于每个组件都要复制一份框架；不打包的话，又做不到开箱即用”。如何看待svelte 这个前端框架，Svelte 解决方案：https://dev.to/silvio/how-to-create-a-web-components-in-svelte-2g4j 跨框架使用 Demo 详见：https://webcomponents.dev/edit/8FfjYicF2OClmsUFivj0/www/index.html\n 兼容性  https://caniuse.com/?search=web%20components 对于不兼容的浏览器可以使用polyfills: webcomponents / polyfills，能够支持到IE11。\n 优势\u0026劣势 优势：  原生支持，web components 依赖浏览器底层的实现，而不限定于某个特定的前端框架 Shadow DOM 实现了真正的局部 CSS 作用域 标准，只有 HTML，CSS，JavaScript，使用它可以不像使用依赖库或者框架的组件一样去额外学习一些框架的特定语言。  劣势：  API 偏底层操作，易用性不够 Css-in-js，性能、可读性差 全局命名空间 DOM操作，影响应用性能？ 发展缓慢  参考文档：  https://developers.google.cn/web/fundamentals/web-components https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/ https://dev.to/emileperron/web-components-in-2021-the-good-the-bad-and-the-ugly-3kg https://labs.thisdot.co/author/luis-aviles https://css-tricks.com/encapsulating-style-and-structure-with-shadow-dom/ https://vaadin.com/learn/tutorials/lit-element/state-management-with-redux https://github.com/obetomuniz/awesome-webcomponents https://github.com/nepaul/awesome-web-components  ","wordCount":"1169","inLanguage":"en","datePublished":"2021-08-18T11:55:12+08:00","dateModified":"2021-08-18T11:55:12+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://gikey.github.io/post/wc/"},"publisher":{"@type":"Organization","name":"Null","logo":{"@type":"ImageObject","url":"https://gikey.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://gikey.github.io accesskey=h title="Null (Alt + H)">Null</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://gikey.github.io/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://gikey.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://gikey.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://gikey.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
基于 Web Components 跨框架组件开发
</h1>
<div class=post-meta>August 18, 2021
</div>
</header>
<div class=post-content><h2 id=什么是-web-components>什么是 Web Components<a hidden class=anchor aria-hidden=true href=#什么是-web-components>#</a></h2>
<p>Web Component 并非单一的技术，而是由一系列 W3C 定义的浏览器标准组成，使得开发者可以构建出浏览器原生支持的组件。这些标准包括：</p>
<ul>
<li><strong>Custom Elements</strong>：带有特定行为且用户自命名的 HTML 元素</li>
<li><strong>Shadow DOM</strong>：对标签和样式的一层 DOM 包装</li>
<li><strong>HTML Templates</strong>：可复用的 HTML 标签，提供了和用户自定义标签相结合的接口</li>
</ul>
<h3 id=custom-elements>Custom Elements<a hidden class=anchor aria-hidden=true href=#custom-elements>#</a></h3>
<p>Web component 提供了自定义标签的方法，可以通过 CustomElementRegistry.define() 方法用来注册一个 custom element，该方法接受以下参数：</p>
<ul>
<li>表示所创建的元素名称的符合 <a href=https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString>DOMString</a> 标准的字符串。custom element 的名称不能是单个单词，且其中必须要有短横线。</li>
<li>用于定义元素行为的类 。</li>
<li>可选参数，一个包含 extends 属性的配置对象，是可选参数。它指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;my-element&#39;</span>, <span style=color:#a6e22e>WordCount</span>, { <span style=color:#66d9ef>extends</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;p&#39;</span> });
</code></pre></div><p>custom elements 可以分为两种：</p>
<ul>
<li><strong>Autonomous custom elements</strong> 是独立的元素，它不继承其他内建的HTML元素。可以直接写成HTML标签的形式，或者是在js中使用：<code>document.createElement("my-element")</code>。</li>
<li><strong>Customized built-in elements</strong> 继承自基本的HTML元素。在创建时，你必须指定所需扩展的元素（正如上面例子所示），使用时，需要先写出基本的元素标签，并通过 is 属性指定custom element的名称<code>&lt;p is="my-element"></code>, 或者 <code>document.createElement("p", { is: "my-element" })</code>。
<img loading=lazy src=/images/wc/ce089fd5-7db5-4c32-8475-57b31e5e6172.png alt>
<img loading=lazy src=/images/wc/f02b0cae-2577-415b-8323-129436600619.png alt>
</li>
</ul>
<h3 id=shadow-dom>Shadow DOM<a hidden class=anchor aria-hidden=true href=#shadow-dom>#</a></h3>
<p>Shadow DOM 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。Shadow DOM 允许将隐藏的 DOM 树附加到常规的 DOM 树中——它以 shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。
<img loading=lazy src=/images/wc/shadowdom.png alt>
</p>
<blockquote>
<ul>
<li>Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。</li>
<li>Shadow tree：Shadow DOM内部的DOM树。</li>
<li>Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。</li>
<li>Shadow root: Shadow tree的根节点。</li>
</ul>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>my-element</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;web component&#34;</span>&gt;&lt;/<span style=color:#f92672>my-element</span> &gt;

&lt;<span style=color:#f92672>script</span>&gt;
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#a6e22e>connectedCallback</span>() {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>shadow</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>attachShadow</span>({<span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;open&#39;</span>});
    <span style=color:#a6e22e>shadow</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`&lt;p&gt;
</span><span style=color:#e6db74>      Hello, </span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getAttribute</span>(<span style=color:#e6db74>&#39;name&#39;</span>)<span style=color:#e6db74>}</span><span style=color:#e6db74>
</span><span style=color:#e6db74>    &lt;/p&gt;`</span>;
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;my-element&#39;</span>, <span style=color:#a6e22e>MyElement</span>); 
&lt;/<span style=color:#f92672>script</span>&gt;
</code></pre></div><h3 id=html-templates>HTML Templates<a hidden class=anchor aria-hidden=true href=#html-templates>#</a></h3>
<p><code>&lt;template></code> 是一种 HTML 元素，所以一个含内容的模板所具备的最基本形式如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>template</span>&gt;
  &lt;<span style=color:#f92672>h1</span>&gt;Hello world&lt;/<span style=color:#f92672>h1</span>&gt;
&lt;/<span style=color:#f92672>template</span>&gt;
</code></pre></div><p>在浏览器中运行这段代码会显示空白页面，因为浏览器并没有渲染模板元素内容。这种方式的强大之处在于它允许我们保存自定义内容（或内容结构），以供后续使用，而不需要使用 JavaScript 来动态编写 HTML 代码。
模板可以包含任意 HTML，包括脚本和样式元素。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>template</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;template&#34;</span>&gt;
  &lt;<span style=color:#f92672>script</span>&gt;
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>button</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;click-me&#39;</span>);
    <span style=color:#a6e22e>button</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#a6e22e>event</span> =&gt; <span style=color:#a6e22e>alert</span>(<span style=color:#a6e22e>event</span>));
  &lt;/<span style=color:#f92672>script</span>&gt;
  &lt;<span style=color:#f92672>style</span>&gt;
    #click-me {
      <span style=color:#66d9ef>all</span>: <span style=color:#66d9ef>unset</span>;
      <span style=color:#66d9ef>background</span>: <span style=color:#66d9ef>tomato</span>;
      <span style=color:#66d9ef>border</span>: <span style=color:#ae81ff>0</span>;
      <span style=color:#66d9ef>border-radius</span>: <span style=color:#ae81ff>4</span><span style=color:#66d9ef>px</span>;
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>white</span>;
      <span style=color:#66d9ef>font-family</span>: Helvetica;
      <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>1.5</span><span style=color:#66d9ef>rem</span>;
      <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>.5</span><span style=color:#66d9ef>rem</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>rem</span>;
    }
  &lt;/<span style=color:#f92672>style</span>&gt;
  &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;click-me&#34;</span>&gt;Log click event&lt;/<span style=color:#f92672>button</span>&gt;
&lt;/<span style=color:#f92672>template</span>&gt;
</code></pre></div><p><code>&lt;slot></code> 使用与 Vue 的用法基本一模一样</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!-- my-paragraph --&gt;</span>
&lt;<span style=color:#f92672>p</span>&gt;&lt;<span style=color:#f92672>slot</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;my-text&#34;</span>&gt;My default text&lt;/<span style=color:#f92672>slot</span>&gt;&lt;/<span style=color:#f92672>p</span>&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>my-element</span>&gt;
  &lt;<span style=color:#f92672>span</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;my-text&#34;</span>&gt;Let&#39;s have some different text!&lt;/<span style=color:#f92672>span</span>&gt;
&lt;/<span style=color:#f92672>my-element</span>&gt;
</code></pre></div><h2 id=生命周期>生命周期<a hidden class=anchor aria-hidden=true href=#生命周期>#</a></h2>
<ul>
<li><strong>constructor</strong>：组件被 create 的时候会被调用，整个生命周期中最早触发也只会触发一次，通常可以在这里做一些初始化私有变量、记录数据的一些操作；但是出于性能和职责分离的考虑，不建议在这里做一些 DOM 相关的事情。</li>
<li><strong>connectedCallback</strong>：组件被连接到 DOM Tree 的时候会触发，这个时机包括节点被插入节点树、节点被从节点树中移动，所以它可能会被触发多次。</li>
<li><strong>disconnectedCallback</strong>：组件被从 DOM Tree 中移除的时候触发。</li>
<li><strong>adoptedCallback</strong>：当 custom element被移动到新的文档时，被调用。<a href=https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptNode>adoptNode</a></li>
<li><strong>attributeChangedCallback</strong>：当组件的 attribute 发生变化的时候触发，它的三个形参分别是 name, oldValue, newValue，如果声明了 properties 对象，对 attribute 的相应值变化也会触发这个回调。需要注意的是，如果覆盖了组件的 observedAttributes 静态方法，properties 对象中声明的值不会触发，它会按照覆盖的 observedAttributes 静态方法的返回值为准。</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyComponent</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> { 
  <span style=color:#a6e22e>constructor</span>() { 
    <span style=color:#66d9ef>super</span>() 
  } 
 
  <span style=color:#a6e22e>connectedCallback</span>(){ 
    <span style=color:#75715e>// 当自定义元素第一次被连接到文档DOM时被调用 
</span><span style=color:#75715e></span>  } 
  <span style=color:#a6e22e>disconnectedCallback</span>(){ 
    <span style=color:#75715e>// 当自定义元素与文档DOM断开连接时被调用 
</span><span style=color:#75715e></span>  } 
  <span style=color:#a6e22e>adoptedCallback</span>(){ 
    <span style=color:#75715e>// 当自定义元素被移动到新文档时被调用 
</span><span style=color:#75715e></span>  } 
  <span style=color:#a6e22e>attributeChangedCallback</span>(){ 
    <span style=color:#75715e>// 当自定义元素的一个属性被增加、移除或更改时被调用 
</span><span style=color:#75715e></span>  } 
}
</code></pre></div><h2 id=组件通信>组件通信<a hidden class=anchor aria-hidden=true href=#组件通信>#</a></h2>
<h3 id=父组件传递数据给子组件>父组件传递数据给子组件<a hidden class=anchor aria-hidden=true href=#父组件传递数据给子组件>#</a></h3>
<ol>
<li>通过 DOM 属性，不支持复杂对象的传递。</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// parentWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parentTemplate</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`&lt;child-wc/&gt;`</span>;
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ParentWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>connectedCallback</span>() {
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;child-wc&#39;</span>)
      <span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#39;text&#39;</span>, <span style=color:#e6db74>&#39;web component&#39;</span>);
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;parent-wc&#39;</span>, <span style=color:#a6e22e>ParentWc</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// childWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChildWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#75715e>// 必须先生命需要监听的属性
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>observedAttributes</span>() {
    <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#39;text&#39;</span>];
  } 

  <span style=color:#a6e22e>attributeChangedCallback</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>oldValue</span>, <span style=color:#a6e22e>newValue</span>) {
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>name</span><span style=color:#f92672>===</span><span style=color:#e6db74>&#39;text&#39;</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>oldValue</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>newValue</span>) {
      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>newValue</span>)
    }
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;child-wc&#39;</span>, <span style=color:#a6e22e>ChildWc</span>);
</code></pre></div><ol start=2>
<li>第二种方式通过组件实例属性。这是目前主流的传值方式，支持复杂对象的传递。</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// parentWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ParentWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
   <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>connectedCallback</span>() {
     <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;child-wc&#39;</span>).<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>text</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;web component&#39;</span>}
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;parent-wc&#39;</span>, <span style=color:#a6e22e>ParentWc</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// childWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChildWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>text</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;child web component&#39;</span> } }
    Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>data</span>, <span style=color:#e6db74>&#39;text&#39;</span>, {
      <span style=color:#a6e22e>set</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>value</span> =&gt; {
        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>value</span>)
      }
    })
  }
}
</code></pre></div><h3 id=子组件传递数据给父组件>子组件传递数据给父组件<a hidden class=anchor aria-hidden=true href=#子组件传递数据给父组件>#</a></h3>
<ol>
<li>第一种通过事件监听，利用原生 CustomEvent 函数来创建自定义事件，然后在子组件实例上派发此事件以及数据，同时父组件进行监听，可以借助 document 设置事件总线，进行跨组件全局通信。</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// childWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChildWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>connectedCallback</span>() {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>event</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>CustomEvent</span>(<span style=color:#e6db74>&#39;custom-event&#39;</span>, {
          <span style=color:#a6e22e>detail</span><span style=color:#f92672>:</span> {
              <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;child web component&#39;</span>
          }
      });
     <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dispatchEvent</span>(<span style=color:#a6e22e>event</span>);
  }
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;child-wc&#39;</span>, <span style=color:#a6e22e>ChildWc</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// parentWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ParentWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>connectedCallback</span>() {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>child</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;child-wc&#39;</span>)
    <span style=color:#a6e22e>child</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;custom-event&#39;</span>, ({ <span style=color:#a6e22e>detail</span> }) =&gt; {
       <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>detail</span>.<span style=color:#a6e22e>value</span>);
    })
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;parent-wc&#39;</span>, <span style=color:#a6e22e>ParentWc</span>)
</code></pre></div><ol start=2>
<li>第二种方式是直接调用父组件方法。</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// parentWc
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ParentWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>say</span>(<span style=color:#a6e22e>msg</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>msg</span>);
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;parent-wc&#39;</span>, <span style=color:#a6e22e>ParentWc</span>)
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ChildWc</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>connectedCallback</span>() {
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getRootNode</span>().<span style=color:#a6e22e>host</span>.<span style=color:#a6e22e>say</span>(<span style=color:#e6db74>&#39;child web component&#39;</span>)
  }
}
window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#39;child-wc&#39;</span>, <span style=color:#a6e22e>ChildWc</span>)
</code></pre></div><h2 id=shadow-dom-样式封装>Shadow DOM 样式封装<a hidden class=anchor aria-hidden=true href=#shadow-dom-样式封装>#</a></h2>
<p>目前，定义一个 shadow DOM 节点样式的唯一方法就是在 shadow root 的内部 HTML 中添加一个 <code>&lt;style></code> 元素。这种方法几乎在所有情况下都能正常工作，因为浏览器会在可能的情况下对这些组件中的样式表进行重写。在 shadow DOM 中我们可以使用link 或者 @import 引入外部样式，但是必须明确元素样式表的位置。</p>
<h3 id=slot-节点设定样式>slot 节点设定样式<a hidden class=anchor aria-hidden=true href=#slot-节点设定样式>#</a></h3>
<p>不会移动用户的 Light DOM， 中内容依然会在原处，这就意味着可以直接在外层直接设置对应的样式。
<img loading=lazy src=/images/wc/44de5016-bc87-4e91-b70b-9d08791a6369.png alt>
</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>style</span>&gt;
  <span style=color:#f92672>h1</span> {
     <span style=color:#960050;background-color:#1e0010>...</span>
  }
&lt;/<span style=color:#f92672>style</span>&gt;

&lt;<span style=color:#f92672>my-counter</span>&gt;
  &lt;<span style=color:#f92672>h1</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;title&#34;</span>&gt;Counter&lt;/<span style=color:#f92672>h1</span>&gt;
&lt;/<span style=color:#f92672>my-counter</span>&gt;
</code></pre></div><p><code>::slotted&lt;selector></code> 可以在 shadow DOM 中为<code>&lt;slot></code>中节点设置样式，<code>::slotted&lt;selector></code>设置的样式只能在最顶层的节点生效：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!-- my-counter --&gt;</span>
&lt;<span style=color:#f92672>style</span>&gt;
   ::<span style=color:#a6e22e>slotted</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>red</span>;
   }
   ::<span style=color:#a6e22e>slotted</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>description</span><span style=color:#f92672>)</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>blue</span>;
   }
   <span style=color:#f92672>&lt;!</span><span style=color:#f92672>--</span> <span style=color:#f92672>不生效</span> <span style=color:#f92672>--</span><span style=color:#f92672>&gt;</span>
   ::<span style=color:#a6e22e>slotted</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>lib</span><span style=color:#f92672>)</span><span style=color:#960050;background-color:#1e0010>，</span>
   ::<span style=color:#a6e22e>slotted</span><span style=color:#f92672>(</span>.<span style=color:#a6e22e>description</span> .<span style=color:#a6e22e>lib</span><span style=color:#f92672>)</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>green</span>;
   }
&lt;/<span style=color:#f92672>style</span>&gt;

&lt;<span style=color:#f92672>my-countr</span>&gt;
  &lt;<span style=color:#f92672>h1</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;title&#34;</span>&gt;Counter&lt;/<span style=color:#f92672>h1</span>&gt;
  &lt;<span style=color:#f92672>p</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;description&#34;</span>&gt;
      A counter build by &lt;<span style=color:#f92672>span</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;lib&#34;</span>&gt;web component&lt;/<span style=color:#f92672>span</span>&gt;
  &lt;/<span style=color:#f92672>p</span>&gt;
&lt;/<span style=color:#f92672>my-counter</span>&gt;
</code></pre></div><h3 id=css-自定义属性>css 自定义属性<a hidden class=anchor aria-hidden=true href=#css-自定义属性>#</a></h3>
<p>css 自定义属性可以传入 shadow DOM 内部，从而调整内部样式，从概念上看，这与<code>&lt;slot></code>类似， 可以简单理解为：创建“样式占位符”以便进行替换：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!-- main page --&gt;</span>
&lt;<span style=color:#f92672>style</span>&gt;
   :<span style=color:#a6e22e>root</span> {
      --primary: <span style=color:#66d9ef>red</span>;
   }
&lt;/<span style=color:#f92672>style</span>&gt;


<span style=color:#75715e>&lt;!-- my-counter --&gt;</span>
&lt;<span style=color:#f92672>style</span>&gt;
   <span style=color:#f92672>div</span> {
     <span style=color:#66d9ef>background-color</span>: <span style=color:#a6e22e>var</span>(<span style=color:#f92672>--</span>primary, <span style=color:#66d9ef>blue</span>);
   }
&lt;/<span style=color:#f92672>style</span>&gt;
</code></pre></div><h3 id=可构造的样式表>可构造的样式表<a hidden class=anchor aria-hidden=true href=#可构造的样式表>#</a></h3>
<p>为了更好地复用样式，可构造的样式表提供了类似于编写普通 CSS 并在多个节点之间共享这些样式的方式。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>everythingTomato</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>CSSStyleSheet</span>();
<span style=color:#a6e22e>everythingTomato</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#39;* { color: tomato; }&#39;</span>);

document.<span style=color:#a6e22e>adoptedStyleSheets</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>everythingTomato</span>];

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCounter</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
  <span style=color:#a6e22e>constructor</span>() {
    <span style=color:#66d9ef>super</span>();
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>adoptedStyleSheets</span> <span style=color:#f92672>=</span> [<span style=color:#a6e22e>everythingTomato</span>];
  }
  
  <span style=color:#a6e22e>connectedCallback</span>() {
    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>`&lt;h1&gt;CSS colors are fun&lt;/h1&gt;`</span>;
  }
}
</code></pre></div><h3 id=part--伪元素>part 伪元素<a hidden class=anchor aria-hidden=true href=#part--伪元素>#</a></h3>
<p>::part 可以结合其他伪类/元素使用，不能再加上选择器</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!-- main page --&gt;</span>
&lt;<span style=color:#f92672>style</span>&gt;
   <span style=color:#f92672>tab-element</span>::<span style=color:#a6e22e>part</span><span style=color:#f92672>(</span><span style=color:#f92672>tab</span><span style=color:#f92672>)</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>grey</span>;
   }
   <span style=color:#f92672>tab-element</span>::<span style=color:#a6e22e>part</span><span style=color:#f92672>(</span><span style=color:#f92672>tab</span><span style=color:#f92672>)</span>:<span style=color:#a6e22e>hover</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>black</span>;
   }
   <span style=color:#f92672>tab-element</span>::<span style=color:#a6e22e>part</span><span style=color:#f92672>(</span><span style=color:#f92672>active</span><span style=color:#f92672>)</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>black</span>;
   }
   
    <span style=color:#f92672>&lt;!</span><span style=color:#f92672>--</span> <span style=color:#f92672>不生效</span> <span style=color:#f92672>--</span><span style=color:#f92672>&gt;</span>
    <span style=color:#f92672>tab-element</span>::<span style=color:#a6e22e>part</span><span style=color:#f92672>(</span><span style=color:#f92672>tab</span><span style=color:#f92672>)</span> <span style=color:#f92672>span</span> {
      <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>white</span>;
   }
&lt;/<span style=color:#f92672>style</span>&gt;


<span style=color:#75715e>&lt;!-- tab-element --&gt;</span>
&lt;<span style=color:#f92672>template</span>&gt;
   &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>part</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;tab active&#34;</span>&gt;
     &lt;<span style=color:#f92672>span</span> <span style=color:#a6e22e>part</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;tab&#34;</span>&gt;
     tab1
     &lt;/<span style=color:#f92672>span</span>&gt;
   &lt;/<span style=color:#f92672>div</span>&gt;
   &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>part</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;tab&#34;</span>&gt;
   &lt;<span style=color:#f92672>span</span>&gt;
     tab2
     &lt;/<span style=color:#f92672>span</span>&gt; 
   &lt;/<span style=color:#f92672>div</span>&gt;
&lt;/<span style=color:#f92672>template</span>&gt;
</code></pre></div><h2 id=demo-实现计数器>Demo: 实现计数器<a hidden class=anchor aria-hidden=true href=#demo-实现计数器>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=color:#75715e>&lt;!DOCTYPE html&gt;</span>
&lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
  &lt;<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;UTF-8&#34;</span> /&gt;
    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>http-equiv</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;X-UA-Compatible&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;IE=edge&#34;</span> /&gt;
    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;viewport&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;width=device-width, initial-scale=1.0&#34;</span> /&gt;
    &lt;<span style=color:#f92672>title</span>&gt;web component demo&lt;/<span style=color:#f92672>title</span>&gt;

    &lt;<span style=color:#f92672>style</span>&gt;
      <span style=color:#f92672>body</span> {
        <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>flex</span>;
        <span style=color:#66d9ef>justify-content</span>: <span style=color:#66d9ef>center</span>;
        <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>50</span><span style=color:#66d9ef>px</span>;
      }
      <span style=color:#f92672>h1</span> {
        <span style=color:#66d9ef>font-size</span>: <span style=color:#ae81ff>30</span><span style=color:#66d9ef>px</span>;
        <span style=color:#66d9ef>text-align</span>: <span style=color:#66d9ef>center</span>;
        <span style=color:#66d9ef>margin-bottom</span>: <span style=color:#ae81ff>40</span><span style=color:#66d9ef>px</span>;
      }
    &lt;/<span style=color:#f92672>style</span>&gt;
    
  &lt;/<span style=color:#f92672>head</span>&gt;
  &lt;<span style=color:#f92672>body</span>&gt;
    &lt;<span style=color:#f92672>my-counter</span>&gt;
      &lt;<span style=color:#f92672>h1</span> <span style=color:#a6e22e>slot</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;title&#34;</span>&gt;Counter&lt;/<span style=color:#f92672>h1</span>&gt;
    &lt;/<span style=color:#f92672>my-counter</span>&gt;
    &lt;<span style=color:#f92672>template</span>&gt;
      &lt;<span style=color:#f92672>style</span>&gt;
        <span style=color:#f92672>span</span> {
          <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>4</span><span style=color:#66d9ef>rem</span>;
          <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>inline-block</span>;
          <span style=color:#66d9ef>text-align</span>: <span style=color:#66d9ef>center</span>;
        }

        <span style=color:#f92672>button</span> {
          <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>4</span><span style=color:#66d9ef>rem</span>;
          <span style=color:#66d9ef>height</span>: <span style=color:#ae81ff>4</span><span style=color:#66d9ef>rem</span>;
          <span style=color:#66d9ef>border</span>: <span style=color:#66d9ef>none</span>;
          <span style=color:#66d9ef>border-radius</span>: <span style=color:#ae81ff>10</span><span style=color:#66d9ef>px</span>;
          <span style=color:#66d9ef>background-color</span>: <span style=color:#66d9ef>seagreen</span>;
          <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>white</span>;
        }
      &lt;/<span style=color:#f92672>style</span>&gt;
      &lt;<span style=color:#f92672>slot</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;title&#34;</span>&gt;&lt;/<span style=color:#f92672>slot</span>&gt;
      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dec&#34;</span>&gt;-&lt;/<span style=color:#f92672>button</span>&gt;
      &lt;<span style=color:#f92672>span</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;count&#34;</span>&gt;&lt;/<span style=color:#f92672>span</span>&gt;
      &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;inc&#34;</span>&gt;+&lt;/<span style=color:#f92672>button</span>&gt;
    &lt;/<span style=color:#f92672>template</span>&gt;
    &lt;<span style=color:#f92672>script</span>&gt;
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>template</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#34;template&#34;</span>);

      <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCounter</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
        <span style=color:#a6e22e>constructor</span>() {
          <span style=color:#66d9ef>super</span>();
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>attachShadow</span>({ <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;open&#34;</span> });
        }

        <span style=color:#a6e22e>connectedCallback</span>() {
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>appendChild</span>(<span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>content</span>.<span style=color:#a6e22e>cloneNode</span>(<span style=color:#66d9ef>true</span>));
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;inc&#34;</span>).<span style=color:#a6e22e>onclick</span> <span style=color:#f92672>=</span> () =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>inc</span>();
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;dec&#34;</span>).<span style=color:#a6e22e>onclick</span> <span style=color:#f92672>=</span> () =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dec</span>();
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span>);
        }

        <span style=color:#a6e22e>inc</span>() {
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>update</span>(<span style=color:#f92672>++</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span>);
        }

        <span style=color:#a6e22e>dec</span>() {
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>update</span>(<span style=color:#f92672>--</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span>);
        }

        <span style=color:#a6e22e>update</span>(<span style=color:#a6e22e>count</span>) {
          <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>shadowRoot</span>.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#34;count&#34;</span>).<span style=color:#a6e22e>innerHTML</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>count</span>;
        }
      }

      window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#e6db74>&#34;my-counter&#34;</span>, <span style=color:#a6e22e>MyCounter</span>);
    &lt;/<span style=color:#f92672>script</span>&gt;
  &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><p>Live demo: <a href=https://webcomponents.dev/edit/Osbw4TzJEizqkd5ZkHOs/www/index.html>https://webcomponents.dev/edit/Osbw4TzJEizqkd5ZkHOs/www/index.html</a></p>
<h2 id=与现代框架对比>与现代框架对比<a hidden class=anchor aria-hidden=true href=#与现代框架对比>#</a></h2>
<p><a href=https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/>https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/</a></p>
<h3 id=bundle-size>Bundle Size<a hidden class=anchor aria-hidden=true href=#bundle-size>#</a></h3>
<p>上面计数器基于各种框架/库实现rollup打包大小如下：
单个组件：
<img loading=lazy src=/images/wc/fbce1131-88df-484a-9e4a-ebbc54f3d64e.png alt>
打包30个：
<img loading=lazy src=/images/wc/ca224e34-b072-4045-ab6c-774776a4e0c7.png alt>
Performance
单个页面中 50个 JS 解析+DOM Tree 创建耗时：
<img loading=lazy src=/images/wc/e86e17fc-0b70-4f21-a2fb-ace75d73620d.png alt>
</p>
<h2 id=开源实现>开源实现<a hidden class=anchor aria-hidden=true href=#开源实现>#</a></h2>
<h3 id=reactvue>React/Vue<a hidden class=anchor aria-hidden=true href=#reactvue>#</a></h3>
<blockquote>
<p>React 和 Web Components 为了解决不同的问题而生。Web Components 为可复用组件提供了强大的封装，而 React 则提供了声明式的解决方案，使 DOM 与数据保持同步。两者旨在互补。作为开发人员，可以自由选择在 Web Components 中使用 React，或者在 React 中使用 Web Components，或者两者共存。
React 和 Vue 开发 Web Component 的思路基本一样，都是用 Custom Elements 包装对应的 React/Vue 组件，以React 为例：</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>React</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react&#39;</span>;
<span style=color:#66d9ef>import</span> <span style=color:#a6e22e>ReactDOM</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;react-dom&#39;</span>;

<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>defineElement</span>(<span style=color:#a6e22e>Component</span>, <span style=color:#a6e22e>elementName</span>, <span style=color:#a6e22e>observedAttributes</span> <span style=color:#f92672>=</span> [], <span style=color:#a6e22e>events</span> <span style=color:#f92672>=</span> []) {
  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomElement</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>HTMLElement</span> {
    <span style=color:#a6e22e>constructor</span>() {
      <span style=color:#66d9ef>super</span>();
      <span style=color:#a6e22e>observedAttributes</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>property</span> =&gt; Object.<span style=color:#a6e22e>defineProperty</span>(<span style=color:#66d9ef>this</span>, <span style=color:#a6e22e>property</span>, { <span style=color:#a6e22e>set</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>value</span> =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>setterProxy</span>(<span style=color:#a6e22e>property</span>, <span style=color:#a6e22e>value</span>) }));
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>events</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>events</span>;
    }

    <span style=color:#a6e22e>setterProxy</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>value</span>) {
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>attributeChangedCallback</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>value</span>); <span style=color:#75715e>// Careful, this is a bug, since the oldVal always equals the new val
</span><span style=color:#75715e></span>    }

    <span style=color:#a6e22e>connectedCallback</span>() {
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>props</span> <span style=color:#f92672>=</span> [...<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>attributes</span>].<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>attribute</span>) =&gt; ({ ...<span style=color:#a6e22e>props</span>, [<span style=color:#a6e22e>attribute</span>.<span style=color:#a6e22e>name</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>attribute</span>.<span style=color:#a6e22e>value</span> }),
        { <span style=color:#a6e22e>root</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>this</span> });

      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Component</span> {...(<span style=color:#a6e22e>props</span>)} <span style=color:#f92672>/&gt;</span>);
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>assignEvents</span>(<span style=color:#a6e22e>instance</span>);
      <span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>render</span>(<span style=color:#a6e22e>instance</span>, <span style=color:#66d9ef>this</span>);
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>instance</span>;
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>props</span>;
    }

    <span style=color:#a6e22e>attributeChangedCallback</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>oldValue</span>, <span style=color:#a6e22e>newValue</span>) {
      <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>instance</span> } <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>;
      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>instance</span>) <span style=color:#66d9ef>return</span>;
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>newProps</span> <span style=color:#f92672>=</span> { ...(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span>), ...({ [<span style=color:#a6e22e>name</span>]<span style=color:#f92672>:</span> <span style=color:#a6e22e>newValue</span> }) };
      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>newInstance</span> <span style=color:#f92672>=</span> (<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Component</span> {...(<span style=color:#a6e22e>newProps</span>)} <span style=color:#f92672>/&gt;</span>);
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>assignEvents</span>(<span style=color:#a6e22e>newInstance</span>);
      <span style=color:#a6e22e>ReactDOM</span>.<span style=color:#a6e22e>render</span>(<span style=color:#a6e22e>newInstance</span>, <span style=color:#66d9ef>this</span>);
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>instance</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newInstance</span>;
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newProps</span>;
    }

    <span style=color:#a6e22e>assignEvents</span>(<span style=color:#a6e22e>instance</span>) {
      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>events</span>.<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>event</span> =&gt; <span style=color:#a6e22e>instance</span>.<span style=color:#a6e22e>props</span>[<span style=color:#a6e22e>event</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>eventArgs</span> =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>dispatchEvent</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>CustomEvent</span>(<span style=color:#a6e22e>event</span>, { <span style=color:#a6e22e>detail</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>eventArgs</span> })));
    }
  }

  <span style=color:#a6e22e>CustomElement</span>.<span style=color:#a6e22e>observedAttributes</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>observedAttributes</span>;
  window.<span style=color:#a6e22e>customElements</span>.<span style=color:#a6e22e>define</span>(<span style=color:#a6e22e>elementName</span>, <span style=color:#a6e22e>CustomElement</span>);
</code></pre></div><blockquote>
<p>React 基于 bitovi/react-to-webcomponent 实现 React 转换 Web Component；
Vue 基于 <a href=https://cli.vuejs.org/zh/guide/build-targets.html>https://cli.vuejs.org/zh/guide/build-targets.html</a> 设置构建目标为 wc 来产出 Web Component，也可以 <a href=https://github.com/vuejs/vue-web-component-wrapper>https://github.com/vuejs/vue-web-component-wrapper</a> 包装一下（需配合vue-style-loader）</p>
</blockquote>
<h3 id=lit>Lit<a hidden class=anchor aria-hidden=true href=#lit>#</a></h3>
<p><a href=https://lit.dev/>Lit</a> 是 Google 提供的一组开源库，可帮助开发者构建快速、轻量且适用于任何框架的组件，<a href=https://codelabs.developers.google.com/codelabs/lit-2-for-react-devs#1>Lit vs React</a>，上面计数器用Lit实现就变得非常简单：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>LitElement</span>, <span style=color:#a6e22e>html</span>, <span style=color:#a6e22e>css</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;lit&#34;</span>;
<span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>customElement</span>, <span style=color:#a6e22e>property</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;lit/decorators.js&#34;</span>;

<span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>customElement</span>(<span style=color:#e6db74>&#34;my-counter&#34;</span>)
<span style=color:#66d9ef>export</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyCounter</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LitElement</span> {
  <span style=color:#66d9ef>static</span> <span style=color:#a6e22e>styles</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>css</span><span style=color:#e6db74>`
</span><span style=color:#e6db74>    div {
</span><span style=color:#e6db74>      display: inline-block;
</span><span style=color:#e6db74>      text-align: center;
</span><span style=color:#e6db74>      font-size: 30px;
</span><span style=color:#e6db74>      width: 50px;
</span><span style=color:#e6db74>      text-align: center;
</span><span style=color:#e6db74>    }
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>    button {
</span><span style=color:#e6db74>      width: 4rem;
</span><span style=color:#e6db74>      height: 4rem;
</span><span style=color:#e6db74>      border: none;
</span><span style=color:#e6db74>      border-radius: 10px;
</span><span style=color:#e6db74>      background-color: seagreen;
</span><span style=color:#e6db74>      color: white;
</span><span style=color:#e6db74>      font-size: 40px;
</span><span style=color:#e6db74>    }
</span><span style=color:#e6db74>  `</span>;

  <span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>state</span>({<span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> Number})
  <span style=color:#a6e22e>count</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>number</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

  <span style=color:#a6e22e>render</span>() {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>html</span><span style=color:#e6db74>`
</span><span style=color:#e6db74>      &lt;slot name=&#34;title&#34;&gt;&lt;/slot&gt;
</span><span style=color:#e6db74>      &lt;button @click=</span><span style=color:#e6db74>${</span>() =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>--</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&gt;-&lt;/button&gt;
</span><span style=color:#e6db74>      &lt;div&gt;</span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&lt;/div&gt;
</span><span style=color:#e6db74>      &lt;button @click=</span><span style=color:#e6db74>${</span>() =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span><span style=color:#e6db74>}</span><span style=color:#e6db74>&gt;+&lt;/button&gt;
</span><span style=color:#e6db74>    `</span>;
  }
}
</code></pre></div><blockquote>
<p>“传统框架和 Web Components 结合最大的问题就在于运行时：单独分发的 WC 里面直接打包框架运行时，等于每个组件都要复制一份框架；不打包的话，又做不到开箱即用”。如何看待svelte 这个前端框架，Svelte 解决方案：https://dev.to/silvio/how-to-create-a-web-components-in-svelte-2g4j
跨框架使用 Demo
详见：https://webcomponents.dev/edit/8FfjYicF2OClmsUFivj0/www/index.html</p>
</blockquote>
<h2 id=兼容性>兼容性<a hidden class=anchor aria-hidden=true href=#兼容性>#</a></h2>
<p><img loading=lazy src=/images/wc/3f06dc05-32c0-497a-8c66-59c29d332b2e.png alt>
<img loading=lazy src=/images/wc/3b2447f5-aabb-4d64-b294-beffb25cbdc1.png alt>
<img loading=lazy src=/images/wc/b48ee14c-ed5a-4c59-a0dc-f646888cd3d9.png alt>
<img loading=lazy src=/images/wc/023acc1e-c802-4b97-aead-cf1b5659e3d3.png alt>
</p>
<blockquote>
<p><a href="https://caniuse.com/?search=web%20components">https://caniuse.com/?search=web%20components</a>
对于不兼容的浏览器可以使用polyfills: webcomponents / polyfills，能够支持到IE11。</p>
</blockquote>
<h2 id=优势劣势>优势&劣势<a hidden class=anchor aria-hidden=true href=#优势劣势>#</a></h2>
<h3 id=优势>优势：<a hidden class=anchor aria-hidden=true href=#优势>#</a></h3>
<ul>
<li>原生支持，web components 依赖浏览器底层的实现，而不限定于某个特定的前端框架</li>
<li>Shadow DOM 实现了真正的局部 CSS 作用域</li>
<li>标准，只有 HTML，CSS，JavaScript，使用它可以不像使用依赖库或者框架的组件一样去额外学习一些框架的特定语言。</li>
</ul>
<h3 id=劣势>劣势：<a hidden class=anchor aria-hidden=true href=#劣势>#</a></h3>
<ul>
<li>API 偏底层操作，易用性不够</li>
<li>Css-in-js，性能、可读性差</li>
<li>全局命名空间</li>
<li>DOM操作，影响应用性能？</li>
<li>发展缓慢</li>
</ul>
<h2 id=参考文档>参考文档：<a hidden class=anchor aria-hidden=true href=#参考文档>#</a></h2>
<ul>
<li><a href=https://developers.google.cn/web/fundamentals/web-components>https://developers.google.cn/web/fundamentals/web-components</a></li>
<li><a href=https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/>https://webcomponents.dev/blog/all-the-ways-to-make-a-web-component/</a></li>
<li><a href=https://dev.to/emileperron/web-components-in-2021-the-good-the-bad-and-the-ugly-3kg>https://dev.to/emileperron/web-components-in-2021-the-good-the-bad-and-the-ugly-3kg</a></li>
<li><a href=https://labs.thisdot.co/author/luis-aviles>https://labs.thisdot.co/author/luis-aviles</a></li>
<li><a href=https://css-tricks.com/encapsulating-style-and-structure-with-shadow-dom/>https://css-tricks.com/encapsulating-style-and-structure-with-shadow-dom/</a></li>
<li><a href=https://vaadin.com/learn/tutorials/lit-element/state-management-with-redux>https://vaadin.com/learn/tutorials/lit-element/state-management-with-redux</a></li>
<li><a href=https://github.com/obetomuniz/awesome-webcomponents>https://github.com/obetomuniz/awesome-webcomponents</a></li>
<li><a href=https://github.com/nepaul/awesome-web-components>https://github.com/nepaul/awesome-web-components</a></li>
</ul>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://gikey.github.io>Null</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>