<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>浏览器缓存机制 | Null</title>
<meta name=keywords content>
<meta name=description content="前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。
WEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：
本篇文章重点讲的就是上面红色框部分缓存内容。
认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。
 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。
 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：
第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：
  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：
 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。
 强缓存：Expires & Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：">
<meta name=author content>
<link rel=canonical href=https://www.xieluping.cn/post/browser-cache/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.xieluping.cn/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.xieluping.cn/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://www.xieluping.cn/favicon-32x32.png>
<link rel=apple-touch-icon href=https://www.xieluping.cn/apple-touch-icon.png>
<link rel=mask-icon href=https://www.xieluping.cn/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<link rel=stylesheet href=https://www.xieluping.cn/css/style.css><meta property="og:title" content="浏览器缓存机制">
<meta property="og:description" content="前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。
WEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：
本篇文章重点讲的就是上面红色框部分缓存内容。
认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。
 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。
 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：
第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：
  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：
 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。
 强缓存：Expires & Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.xieluping.cn/post/browser-cache/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2018-09-17T15:59:31+08:00">
<meta property="article:modified_time" content="2018-09-17T15:59:31+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="浏览器缓存机制">
<meta name=twitter:description content="前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。
WEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：
本篇文章重点讲的就是上面红色框部分缓存内容。
认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。
 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。
 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：
第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：
  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：
 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。
 强缓存：Expires & Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.xieluping.cn/post/"},{"@type":"ListItem","position":3,"name":"浏览器缓存机制","item":"https://www.xieluping.cn/post/browser-cache/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"浏览器缓存机制","name":"浏览器缓存机制","description":"前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。\nWEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：\n本篇文章重点讲的就是上面红色框部分缓存内容。\n认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。\n 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。\n 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：\n第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：\n  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：\n 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n 强缓存：Expires \u0026amp; Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：","keywords":[],"articleBody":"前言 在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。 一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。 所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。\nWEB缓存体系 在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：\n本篇文章重点讲的就是上面红色框部分缓存内容。\n认识浏览器缓存 当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。\n 这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。\n 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：\n第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。 浏览器启用缓存至少有两点显而易见的好处：（1）减少页面加载时间；（2）减少服务器负载； 浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：\n  通用首部字段（就是请求报文和响应报文都能用上的字段）   请求首部字段   响应首部字段   实体首部字段   浏览器缓存机制 根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：\n 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器； 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源； 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n 强缓存：Expires \u0026 Cache-Control 当浏览器对某个资源的请求命中了强缓存时，返回的 HTTP 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：\n 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。\n Expires 是 HTTP 1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires 头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。\n例如，一个文件的 Expires 值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。 所以，Expires 是优化中最理想的情况，因为它根本不会产生请求，所以后端也就无需考虑查询快慢。它的缓存原理，如下：\n  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Expires 的 header，如：   浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；\n  浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行；\n  如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新；\n  Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如：随意修改下客户端时间，就能影响缓存命中的结果。所以在 HTTP 1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：\n  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Cache-Control 的 header，如：   浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；\n  浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；\n  如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新；\n  Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。 这两个 header 可以只启用一个，也可以同时启用，当 response header中，Expires 和 Cache-Control 同时存在时，Cache-Control优先级高于 Expires： 此外，还可以为 Cache-Control 指定 public 或 private 标记。如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。对于 public，则允许所有服务器缓存该资源。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），Cache-Control 默认设为 public 是合理的。\n协商缓存：Last-Modified \u0026 Etag 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为304并且会显示一个 Not Modified 的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的： 查看单个请求的 Response Header，也能看到304的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：  协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。\n  【Last-Modified，If-Modified-Since】的控制缓存的原理，如下：  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：  浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：   服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回304时的 response header：   浏览器收到304的响应后，就会从缓存中加载资源。\n  如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。\n  【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：   浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：   浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值：   服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：   浏览器收到304的响应后，就会从缓存中加载资源。\n  Etag 和 Last-Modified 非常相似，都是用来判断一个参数，从而决定是否启用缓存。但是 ETag 相对于 Last-Modified 也有其优势，可以更加准确的判断文件内容是否被修改，从而在实际操作中实用程度也更高。 协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache: 如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。 【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：\n 分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败； 分布式系统尽量关闭掉 ETag (每台机器生成的 ETag 都会不一样）；\n 比如，京东页面的资源请求，返回的 repsonse header 就只有 Last-Modified，没有 ETag： 协商缓存需要配合强缓存使用，上面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。\n缓存判断流程 如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下： 总结 最后整理下 http 缓存及其优先级。\n  强缓存和协商缓存同时存在，如果强缓存还在生效期则强制缓存覆盖协商缓存，协商缓存不生效；如果强缓存不在有效期，协商缓存生效。即：强缓存优先级  协商缓存优先级\n  强缓存 Expires 和 Cache-Control 同时存在时，则 Cache-Control 会覆盖 Expires，Expires 无论有没有过期，都无效。 即：Cache-Control 优先级  Expires 优先级。\n  协商缓存 Etag 和 Last-Modified 同时存在时，则 Etag 会覆盖 Last-Modified，Last-Modified 不会生效。即：ETag 优先级  Last-Modified 优先级。\n  当然还有一种缓存pragma，和 Cache-Control 类似，前者是http1.0内容后者是http1.1内容，并且pragma优先级  Cache-Control 优先级，不过前者目前基本不使用。\n","wordCount":"349","inLanguage":"en","datePublished":"2018-09-17T15:59:31+08:00","dateModified":"2018-09-17T15:59:31+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.xieluping.cn/post/browser-cache/"},"publisher":{"@type":"Organization","name":"Null","logo":{"@type":"ImageObject","url":"https://www.xieluping.cn/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.xieluping.cn accesskey=h title="Null (Alt + H)">Null</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.xieluping.cn/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
浏览器缓存机制
</h1>
<div class=post-meta>September 17, 2018
</div>
</header>
<div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2>
<p>在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。<strong>其中提高网页反应速度的一个方式就是使用缓存</strong>。缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。
一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。
所以，缓存技术是无数WEB开发从业人员在工作过程中不可避免的一大问题。在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。希望能对有需要的人有所帮助。</p>
<h2 id=web缓存体系>WEB缓存体系<a hidden class=anchor aria-hidden=true href=#web缓存体系>#</a></h2>
<p>在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如：用户层、系统层、代理层、前端、后端、服务端等，<strong>每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟</strong>，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。所以，我们首先看下各层的缓存都有哪些技术，都缓存哪些数据，从整体上，对WEB的缓存技术进行了解，如下图所示：</p>
<p><img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74ced1550cb8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<p>本篇文章重点讲的就是上面红色框部分缓存内容。</p>
<h2 id=认识浏览器缓存>认识浏览器缓存<a hidden class=anchor aria-hidden=true href=#认识浏览器缓存>#</a></h2>
<p>当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。</p>
<blockquote>
<p>这些被浏览器保存的文件就被称为缓存（不是指Cookie或者Localstorage）。</p>
</blockquote>
<p>那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：</p>
<p><img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74ced0854320?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<p>第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分 size 有具体数值，然而还有一部分请求，比如图片、css 和 js 等文件并没有显示文件大小，而是显示了 <code>from dis cache</code> 或者 <code>from memory cache</code>字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。
浏览器启用缓存至少有两点显而易见的好处：<strong>（1）减少页面加载时间；（2）减少服务器负载；</strong>
浏览器是否使用缓存、缓存多久，是由服务器控制的。准确来说，当浏览器请求一个网页（或者其他资源）时，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息。下面看下，HTTP 报文中与缓存相关的首部字段：</p>
<ol>
<li>
<p>通用首部字段（就是请求报文和响应报文都能用上的字段）
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74ced137bcc2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>请求首部字段
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74ced09f1146?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>响应首部字段
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74ced1676641?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>实体首部字段
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74cedc1725cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
</ol>
<h2 id=浏览器缓存机制>浏览器缓存机制<a hidden class=anchor aria-hidden=true href=#浏览器缓存机制>#</a></h2>
<p>根据上面四种类型的首部字段不同使用策略，浏览器中缓存可分为强缓存和协商缓存：</p>
<blockquote>
<p>1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，<strong>强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器</strong>。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器；
2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，<strong>通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存</strong>，如果协商缓存命中，服务器会将这个请求返回，<strong>但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源</strong>，于是浏览器就又会从自己的缓存中去加载这个资源；
3）强缓存与协商缓存的共同点是：<strong>如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据</strong>；区别是：<strong>强缓存不发请求到服务器，协商缓存会发请求到服务器</strong>。
4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>
</blockquote>
<h3 id=强缓存expires--cache-control>强缓存：Expires & Cache-Control<a hidden class=anchor aria-hidden=true href=#强缓存expires--cache-control>#</a></h3>
<p>当浏览器对某个资源的请求命中了强缓存时，<strong>返回的 HTTP 状态为200</strong>，在 chrome 的开发者工具的 network 里面 <strong>size 会显示为 from cache</strong>，比如：京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：</p>
<p><img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74cef1897f96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<blockquote>
<p>强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。</p>
</blockquote>
<p><strong>Expires 是 HTTP 1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示</strong>，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires 头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。</p>
<p>例如，一个文件的 Expires 值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。
所以，<strong>Expires 是优化中最理想的情况，因为它根本不会产生请求</strong>，所以后端也就无需考虑查询快慢。它的缓存原理，如下：</p>
<ol>
<li>
<p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Expires 的 header，如：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74cf04b04c8a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；</p>
</li>
<li>
<p>浏览器再请求这个资源时，<strong>先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较</strong>，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行；</p>
</li>
<li>
<p>如果缓存没有命中，浏览器直接从服务器加载资源时，<strong>Expires Header 在重新加载的时候会被更新</strong>；</p>
</li>
</ol>
<p>Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如：随意修改下客户端时间，就能影响缓存命中的结果。所以在 HTTP 1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ol>
<li>
<p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Cache-Control 的 header，如：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74cf19190d29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；</p>
</li>
<li>
<p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</p>
</li>
<li>
<p>如果缓存没有命中，浏览器直接从服务器加载资源时，<strong>Cache-Control Header 在重新加载的时候会被更新</strong>；</p>
</li>
</ol>
<p>Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。
这两个 header 可以只启用一个，也可以同时启用，当 response header中，Expires 和 Cache-Control 同时存在时，Cache-Control优先级高于 Expires：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74cf18869548?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<p>此外，还可以为 Cache-Control 指定 public 或 private 标记。<strong>如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源</strong>。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。<strong>对于 public，则允许所有服务器缓存该资源</strong>。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），<strong>Cache-Control 默认设为 public 是合理的</strong>。</p>
<h3 id=协商缓存last-modified--etag>协商缓存：Last-Modified & Etag<a hidden class=anchor aria-hidden=true href=#协商缓存last-modified--etag>#</a></h3>
<p>当浏览器对某个资源的请求没有命中强缓存，<strong>就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为304并且会显示一个 Not Modified 的字符串</strong>，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74cf1570ab4b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<p>查看单个请求的 Response Header，<strong>也能看到304的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的</strong>，而不是服务器最新的资源：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0451f2563?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<blockquote>
<p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。</p>
</blockquote>
<ol>
<li>【Last-Modified，If-Modified-Since】的控制缓存的原理，如下：</li>
</ol>
<p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0480c1ca9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<ol start=2>
<li>
<p>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d05d4fbf77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>服务器再次收到资源请求时，<strong>根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化</strong>，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。<strong>当服务器返回304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header</strong>，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回304时的 response header：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d05d37cc80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>浏览器收到304的响应后，就会从缓存中加载资源。</p>
</li>
<li>
<p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<strong>Last-Modified Header 在重新加载的时候会被更新</strong>，下次请求时，<strong>If-Modified-Since 会启用上次返回的 Last-Modified 值</strong>。</p>
</li>
</ol>
<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e587fdf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<ol>
<li>
<p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，<strong>这个唯一标识是一个字符串，只要资源有变化这个串就不同</strong>，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e587fdf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>浏览器再次跟服务器请求这个资源时，<strong>在 request 的 header 上加上 If-None-Match 的 header</strong>，这个 header 的值就是上一次请求时返回的 ETag 的值：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d05d5f4171?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p><strong>服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag</strong>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified 的响应时，<strong>由于 ETag 重新生成过，response header 中还会把这个 ETag 返回</strong>，即使这个 ETag 跟之前的没有变化：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e5592563?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
</li>
<li>
<p>浏览器收到304的响应后，就会从缓存中加载资源。</p>
</li>
</ol>
<p>Etag 和 Last-Modified 非常相似，都是用来判断一个参数，从而决定是否启用缓存。<strong>但是 ETag 相对于 Last-Modified 也有其优势，可以更加准确的判断文件内容是否被修改</strong>，从而在实际操作中实用程度也更高。
协商缓存跟强缓存不一样，强缓存不发请求到服务器，<strong>所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器</strong>，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache:
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e536d23e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。
【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：</p>
<blockquote>
<p><strong>分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；</strong>
<strong>分布式系统尽量关闭掉 ETag (每台机器生成的 ETag 都会不一样）；</strong></p>
</blockquote>
<p>比如，京东页面的资源请求，返回的 repsonse header 就只有 Last-Modified，没有 ETag：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e57befb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<p>协商缓存需要配合强缓存使用，上面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，<strong>因为如果不启用强缓存的话，协商缓存根本没有意义</strong>。</p>
<h2 id=缓存判断流程>缓存判断流程<a hidden class=anchor aria-hidden=true href=#缓存判断流程>#</a></h2>
<p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下：
<img loading=lazy src=https://user-gold-cdn.xitu.io/2018/9/8/165b74d0e55dda0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 alt>
</p>
<h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2>
<p>最后整理下 http 缓存及其优先级。</p>
<ol>
<li>
<p>强缓存和协商缓存同时存在，如果强缓存还在生效期则强制缓存覆盖协商缓存，协商缓存不生效；如果强缓存不在有效期，协商缓存生效。即：强缓存优先级 > 协商缓存优先级</p>
</li>
<li>
<p>强缓存 Expires 和 Cache-Control 同时存在时，则 Cache-Control 会覆盖 Expires，Expires 无论有没有过期，都无效。 即：Cache-Control 优先级 > Expires 优先级。</p>
</li>
<li>
<p>协商缓存 Etag 和 Last-Modified 同时存在时，则 Etag 会覆盖 Last-Modified，Last-Modified 不会生效。即：ETag 优先级 > Last-Modified 优先级。</p>
</li>
</ol>
<p>当然还有一种缓存pragma，和 Cache-Control 类似，前者是http1.0内容后者是http1.1内容，并且pragma优先级 > Cache-Control 优先级，不过前者目前基本不使用。</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://www.xieluping.cn>Null</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>