<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>AngularJS Directive 隔离 Scope 数据交互 | Null</title>
<meta name=keywords content="AngularJS">
<meta name=description content="什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。
为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：
共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。
js代码：
app.controller(&#34;myController&#34;, function ($scope) { $scope.name = &#34;hello world&#34;; }).directive(&#34;shareDirective&#34;, function () { return { template: 'Say:{{name}}' } }); html代码:
<div ng-controller=&#34;myController&#34;> <div share-directive=&#34;&#34;></div> </div> 输出结果：">
<meta name=author content>
<link rel=canonical href=https://www.xieluping.cn/post/ng-scope/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.xieluping.cn/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.xieluping.cn/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://www.xieluping.cn/favicon-32x32.png>
<link rel=apple-touch-icon href=https://www.xieluping.cn/apple-touch-icon.png>
<link rel=mask-icon href=https://www.xieluping.cn/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<link rel=stylesheet href=https://www.xieluping.cn/css/style.css><meta property="og:title" content="AngularJS Directive 隔离 Scope 数据交互">
<meta property="og:description" content="什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。
为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：
共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。
js代码：
app.controller(&#34;myController&#34;, function ($scope) { $scope.name = &#34;hello world&#34;; }).directive(&#34;shareDirective&#34;, function () { return { template: 'Say:{{name}}' } }); html代码:
<div ng-controller=&#34;myController&#34;> <div share-directive=&#34;&#34;></div> </div> 输出结果：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.xieluping.cn/post/ng-scope/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2017-03-08T11:39:09+08:00">
<meta property="article:modified_time" content="2017-03-08T11:39:09+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="AngularJS Directive 隔离 Scope 数据交互">
<meta name=twitter:description content="什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。
为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：
共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。
js代码：
app.controller(&#34;myController&#34;, function ($scope) { $scope.name = &#34;hello world&#34;; }).directive(&#34;shareDirective&#34;, function () { return { template: 'Say:{{name}}' } }); html代码:
<div ng-controller=&#34;myController&#34;> <div share-directive=&#34;&#34;></div> </div> 输出结果：">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.xieluping.cn/post/"},{"@type":"ListItem","position":3,"name":"AngularJS Directive 隔离 Scope 数据交互","item":"https://www.xieluping.cn/post/ng-scope/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AngularJS Directive 隔离 Scope 数据交互","name":"AngularJS Directive 隔离 Scope 数据交互","description":"什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。\n为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：\n共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。\njs代码：\napp.controller(\u0026#34;myController\u0026#34;, function ($scope) { $scope.name = \u0026#34;hello world\u0026#34;; }).directive(\u0026#34;shareDirective\u0026#34;, function () { return { template: \u0026#39;Say:{{name}}\u0026#39; } }); html代码:\n\u0026lt;div ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;div share-directive=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 输出结果：","keywords":["AngularJS"],"articleBody":"什么是隔离 Scope AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。\n为什么使用隔离 Scope 当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：\n共享 scope 使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。\njs代码：\napp.controller(\"myController\", function ($scope) { $scope.name = \"hello world\"; }).directive(\"shareDirective\", function () { return { template: 'Say:{{name}}' } }); html代码:\ndiv ng-controller=\"myController\" div share-directive=\"\"div div 输出结果：\nSay:hello world 隔离 scope 使用隔离 scope 的时候，无法从父 scope 中共享属性。因此下面示例无法输出父 scope 中定义的 name 属性值。\njs代码：\napp.controller(\"myController\", function ($scope) { $scope.name = \"hello world\"; }).directive(\"isolatedDirective\", function () { return { scope: {}, template: 'Say:{{name}}' } }); html代码：\ndiv ng-controller=\"myController\" div isolated-directive=\"\"div div 输出结果：\nSay: 从上图可以看出共享 scope 允许从父 scope 渗入到 directive 中，而隔离 scope 不能，在隔离 scope 下，给 directive 创造了一堵墙，使得父 scope 无法渗入到 directive 中。\n具体文档可以参考：https://docs.angularjs.org/guide/directive#isolating-the-scope-of-a-directive\n如何在 directive 中创建隔离 scope 在 Directive 中创建隔离 scope 很简单，只需要定义一个 scope 属性即可，这样，这个 directive 的 scope 将会创建一个新的 scope，如果多个 directive 定义在同一个元素上，只会创建一个新的 scope。\nangular.module('app').controller(\"myController\", function ($scope) { $scope.user = { id:1, name:\"hello world\" }; }).directive('isolatedScope', function () { return { scope: {}, template: 'Name: {{user.name}} Street: {{user.addr}}' }; }); 现在 scope 是隔离的，user 对象将无法从父 scope 中访问，因此，在 directive 渲染的时候 user 对象的占位将不会输出内容。\n隔离 scope 和父 scope 如何交互 directive 在使用隔离 scope 的时候，提供了三种方法同隔离之外的地方交互。这三种分别是:\n @ 绑定一个局部 scope 属性到当前 dom 节点的属性值。结果总是一个字符串，因为 dom 属性是字符串。 \u0026 提供一种方式执行一个表达式在父 scope 的上下文中。如果没有指定 attr 名称，则属性名称为相同的本地名称。 = 通过 directive 的 attr 属性的值在局部 scope 的属性和父 scope 属性名之间建立双向绑定。  @ 局部 scope 属性 @ 方式局部属性用来访问 directive 外部环境定义的字符串值，主要是通过 directive 所在的标签属性绑定外部字符串值。这种绑定是单向的，即父 scope 的绑定变化，directive 中的 scope 的属性会同步变化，而隔离 scope 中的绑定变化，父 scope 是不知道的。\n如下示例：directive 声明未隔离 scope 类型，并且使用@绑定 name 属性，在 directive 中使用 name 属性绑定父 scope 中的属性。当改变父 scope 中属性的值的时候，directive 会同步更新值，当改变 directive 的 scope 的属性值时，父 scope 无法同步更新值。\njs 代码：\napp.controller(\"myController\", function ($scope) { $scope.name = \"hello world\"; }).directive(\"isolatedDirective\", function () { return { scope: { name: \"@\" }, template: 'Say：{{name}} 改变隔离scope的name：' } }) html 代码：\ndiv ng-controller=\"myController\" div class=\"result\" div父scope： divSay：{{name}}br改变父scope的name：input type=\"text\" value=\"\" ng-model=\"name\"/div div div隔离scope： div isolated-directive name=\"{{name}}\"div div div隔离scope（不使用{{name}}）： div isolated-directive name=\"name\"div div div = 局部 scope 属性 = 通过 directive 的 attr 属性的值在局部 scope 的属性和父 scope 属性名之间建立双向绑定。 意思是，当你想要一个双向绑定的属性的时候，你可以使用=来引入外部属性。无论是改变父 scope 还是隔离 scope 里的属性，父 scope 和隔离 scope 都会同时更新属性值，因为它们是双向绑定的关系。\njs 代码：\napp.controller(\"myController\", function ($scope) { $scope.user = { name: 'hello', id: 1 }; }).directive(\"isolatedDirective\", function () { return { scope: { user: \"=\" }, template: 'Say：{{user.name}} 改变隔离scope的name：' } }) html 代码：\ndiv ng-controller=\"myController\" div父scope： divSay：{{user.name}}br改变父scope的name：input type=\"text\" value=\"\" ng-model=\"user.name\"/div div div隔离scope： div isolated-directive user=\"user\"div div div隔离scope（使用{{name}}）： div isolated-directive user=\"{{user}}\"div div div \u0026 局部 scope 属性 \u0026 方式提供一种途经是 directive 能在父 scope 的上下文中执行一个表达式。此表达式可以是一个 function。 比如当你写了一个 directive，当用户点击按钮时，directive 想要通知 controller，controller 无法知道 directive 中发生了什么，也许你可以通过使用 angular 中的 event 广播来做到，但是必须要在 controller 中增加一个事件监听方法。 最好的方法就是让 directive 可以通过一个父 scope 中的 function，当 directive 中有什么动作需要更新到父 scope 中的时候，可以在父 scope 上下文中执行一段代码或者一个函数。\n如下示例在 directive 中执行父 scope 的 function。\njs代码：\napp.controller(\"myController\", function ($scope) { $scope.value = \"hello world\"; $scope.click = function () { $scope.value = Math.random(); }; }).directive(\"isolatedDirective\", function () { return { scope: { action: \"\u0026\" }, template: '' } }) html 代码：\ndiv ng-controller=\"myController\" div父scope： divSay：{{value}}div div div隔离scope： div isolated-directive action=\"click()\"div div div 以上内容转自：https://blog.coding.net/blog/angularjs-directive-isolate-scope\n小结 相信关于隔离 scope 和父 scope 如何交互的三种方法已经介绍得非常清楚了，最后发现stackoverflow上面有个更加简单直接的解释，原文如下：\nAll three bindings are ways of passing data from your parent scope to your directive’s isolated scope through the element’s attributes:\n  @ binding is for passing strings. These strings support {{}} expressions for interpolated values. For example: . The interpolated expression is evaluated against directive’s parent scope.    = binding is for two-way model binding. The model in parent scope is linked to the model in the directive’s isolated scope. Changes to one model affects the other, and vice versa.    \u0026 binding is for passing a method into your directive’s scope so that it can be called within your directive. The method is pre-bound to the directive’s parent scope, and supports arguments. For example if the method is hello(name) in parent scope, then in order to execute the method from inside your directive, you must call $scope.hello({name:‘world’})   I find that it’s easier to remember these differences by referring to the scope bindings by a shorter description:\n @ Attribute string binding = Two-way model binding \u0026 Callback method binding  The symbols also make it clearer as to what the scope variable represents inside of your directive’s implementation:\n @ string = model \u0026 method  In order of usefulness (for me anyways):\n = @ \u0026  更多请参考API文档：https://docs.angularjs.org/api/ng/service/$compile 。\n","wordCount":"695","inLanguage":"en","datePublished":"2017-03-08T11:39:09+08:00","dateModified":"2017-03-08T11:39:09+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.xieluping.cn/post/ng-scope/"},"publisher":{"@type":"Organization","name":"Null","logo":{"@type":"ImageObject","url":"https://www.xieluping.cn/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.xieluping.cn accesskey=h title="Null (Alt + H)">Null</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.xieluping.cn/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
AngularJS Directive 隔离 Scope 数据交互
</h1>
<div class=post-meta>March 8, 2017
</div>
</header>
<div class=post-content><h2 id=什么是隔离-scope>什么是隔离 Scope<a hidden class=anchor aria-hidden=true href=#什么是隔离-scope>#</a></h2>
<p>AngularJS 的 directive 默认能共享父 scope 中定义的属性，例如在模版中直接使用父 scope 中的对象和属性。通常使用这种直接共享的方式可以实现一些简单的 directive 功能。当你需要创建一个可重复使用的 directive，只是偶尔需要访问或者修改父 scope 的数据，就需要使用隔离 scope。当使用隔离 scope 的时候，directive 会创建一个没有依赖父 scope 的 scope，并提供一些访问父 scope 的方式。</p>
<h2 id=为什么使用隔离-scope>为什么使用隔离 Scope<a hidden class=anchor aria-hidden=true href=#为什么使用隔离-scope>#</a></h2>
<p>当你想要写一个可重复使用的 directive，不能再依赖父 scope，这时候就需要使用隔离 scope 代替。共享 scope 可以直接共享父 scope，而隔离 scope 无法共享父scope。下图解释共享 scope 和隔离 scope 的区别：</p>
<p><img loading=lazy src=https://cdn.xieluping.cn/images/6502f268-800e-4874-8443-d7bebf1b12f0.png alt>
</p>
<h3 id=共享-scope>共享 scope<a hidden class=anchor aria-hidden=true href=#共享-scope>#</a></h3>
<p>使用共享 scope 的时候，可以直接从父 scope 中共享属性。因此下面示例可以将那么属性的值输出出来。使用的是父 scope 中定义的值。</p>
<p>js代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#34;myController&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>$scope</span>) {
    <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello world&#34;</span>;
}).<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#34;shareDirective&#34;</span>, <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>return</span> {
        <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Say:{{name}}&#39;</span>
    }
});
</code></pre></div><p>html代码:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>ng-controller</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myController&#34;</span>&gt;
&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>share-directive</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
&lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><p>输出结果：</p>
<pre><code>Say:hello world
</code></pre><h3 id=隔离-scope>隔离 scope<a hidden class=anchor aria-hidden=true href=#隔离-scope>#</a></h3>
<p>使用隔离 scope 的时候，无法从父 scope 中共享属性。因此下面示例无法输出父 scope 中定义的 name 属性值。</p>
<p>js代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#34;myController&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>$scope</span>) {
    <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello world&#34;</span>;
}).<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#34;isolatedDirective&#34;</span>, <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>return</span> {
        <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> {},
        <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Say:{{name}}&#39;</span>
    }
});
</code></pre></div><p>html代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>ng-controller</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myController&#34;</span>&gt;
&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>isolated-directive</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
&lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><p>输出结果：</p>
<pre><code>Say:
</code></pre><p>从上图可以看出共享 scope 允许从父 scope 渗入到 directive 中，而隔离 scope 不能，在隔离 scope 下，给 directive 创造了一堵墙，使得父 scope 无法渗入到 directive 中。</p>
<p>具体文档可以参考：https://docs.angularjs.org/guide/directive#isolating-the-scope-of-a-directive</p>
<h2 id=如何在-directive-中创建隔离-scope>如何在 directive 中创建隔离 scope<a hidden class=anchor aria-hidden=true href=#如何在-directive-中创建隔离-scope>#</a></h2>
<p>在 Directive 中创建隔离 scope 很简单，只需要定义一个 scope 属性即可，这样，这个 directive 的 scope 将会创建一个新的 scope，如果多个 directive 定义在同一个元素上，只会创建一个新的 scope。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>angular</span>.<span style=color:#a6e22e>module</span>(<span style=color:#e6db74>&#39;app&#39;</span>).<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#34;myController&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>$scope</span>) {
    <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> {
        <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>,
        <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#34;hello world&#34;</span>
    };
}).<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#39;isolatedScope&#39;</span>, <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>return</span> {
        <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> {},
        <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Name: {{user.name}} Street: {{user.addr}}&#39;</span>
    };
});
</code></pre></div><p>现在 scope 是隔离的，user 对象将无法从父 scope 中访问，因此，在 directive 渲染的时候 user 对象的占位将不会输出内容。</p>
<h2 id=隔离-scope-和父-scope-如何交互>隔离 scope 和父 scope 如何交互<a hidden class=anchor aria-hidden=true href=#隔离-scope-和父-scope-如何交互>#</a></h2>
<p>directive 在使用隔离 scope 的时候，提供了三种方法同隔离之外的地方交互。这三种分别是:</p>
<ul>
<li><code>@</code> 绑定一个局部 scope 属性到当前 dom 节点的属性值。结果总是一个字符串，因为 dom 属性是字符串。</li>
<li><code>&</code> 提供一种方式执行一个表达式在父 scope 的上下文中。如果没有指定 attr 名称，则属性名称为相同的本地名称。</li>
<li><code>=</code> 通过 directive 的 attr 属性的值在局部 scope 的属性和父 scope 属性名之间建立双向绑定。</li>
</ul>
<h3 id=-局部-scope-属性>@ 局部 scope 属性<a hidden class=anchor aria-hidden=true href=#-局部-scope-属性>#</a></h3>
<p><code>@</code> 方式局部属性用来访问 directive 外部环境定义的字符串值，主要是通过 directive 所在的标签属性绑定外部字符串值。这种绑定是单向的，即父 scope 的绑定变化，directive 中的 scope 的属性会同步变化，而隔离 scope 中的绑定变化，父 scope 是不知道的。</p>
<p>如下示例：directive 声明未隔离 scope 类型，并且使用<code>@</code>绑定 name 属性，在 directive 中使用 name 属性绑定父 scope 中的属性。当改变父 scope 中属性的值的时候，directive 会同步更新值，当改变 directive 的 scope 的属性值时，父 scope 无法同步更新值。</p>
<p>js 代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#34;myController&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>$scope</span>) {
     <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello world&#34;</span>;
}).<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#34;isolatedDirective&#34;</span>, <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>return</span> {
        <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> {
            <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;@&#34;</span>
        },
        <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Say：{{name}} &lt;br&gt;改变隔离scope的name：&lt;input type=&#34;buttom&#34; value=&#34;&#34; ng-model=&#34;name&#34; class=&#34;ng-pristine ng-valid&#34;&gt;&#39;</span>
    }
})
</code></pre></div><p>html 代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>ng-controller</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myController&#34;</span>&gt;
   &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;result&#34;</span>&gt;
       &lt;<span style=color:#f92672>div</span>&gt;父scope：
           &lt;<span style=color:#f92672>div</span>&gt;Say：{{name}}&lt;<span style=color:#f92672>br</span>&gt;改变父scope的name：&lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> <span style=color:#a6e22e>value</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> <span style=color:#a6e22e>ng-model</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;name&#34;</span>/&gt;&lt;/<span style=color:#f92672>div</span>&gt;
       &lt;/<span style=color:#f92672>div</span>&gt;
       &lt;<span style=color:#f92672>div</span>&gt;隔离scope：
           &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>isolated-directive</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;{{name}}&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
       &lt;/<span style=color:#f92672>div</span>&gt;
        &lt;<span style=color:#f92672>div</span>&gt;隔离scope（不使用{{name}}）：
             &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>isolated-directive</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;name&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
         &lt;/<span style=color:#f92672>div</span>&gt;
   &lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><h3 id=-局部-scope-属性-1>= 局部 scope 属性<a hidden class=anchor aria-hidden=true href=#-局部-scope-属性-1>#</a></h3>
<p><code>=</code> 通过 directive 的 attr 属性的值在局部 scope 的属性和父 scope 属性名之间建立双向绑定。
意思是，当你想要一个双向绑定的属性的时候，你可以使用<code>=</code>来引入外部属性。无论是改变父 scope 还是隔离 scope 里的属性，父 scope 和隔离 scope 都会同时更新属性值，因为它们是双向绑定的关系。</p>
<p>js 代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js> <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#34;myController&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>$scope</span>) {
     <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> {
         <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;hello&#39;</span>,
         <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>
     };
 }).<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#34;isolatedDirective&#34;</span>, <span style=color:#66d9ef>function</span> () {
     <span style=color:#66d9ef>return</span> {
         <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> {
             <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=&#34;</span>
         },
         <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Say：{{user.name}} &lt;br&gt;改变隔离scope的name：&lt;input type=&#34;buttom&#34; value=&#34;&#34; ng-model=&#34;user.name&#34;/&gt;&#39;</span>
      }
 })
</code></pre></div><p>html 代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>ng-controller</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myController&#34;</span>&gt;
    &lt;<span style=color:#f92672>div</span>&gt;父scope：
        &lt;<span style=color:#f92672>div</span>&gt;Say：{{user.name}}&lt;<span style=color:#f92672>br</span>&gt;改变父scope的name：&lt;<span style=color:#f92672>input</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> <span style=color:#a6e22e>value</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> <span style=color:#a6e22e>ng-model</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;user.name&#34;</span>/&gt;&lt;/<span style=color:#f92672>div</span>&gt;
    &lt;/<span style=color:#f92672>div</span>&gt;
    &lt;<span style=color:#f92672>div</span>&gt;隔离scope：
        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>isolated-directive</span> <span style=color:#a6e22e>user</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;user&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
    &lt;/<span style=color:#f92672>div</span>&gt;
    &lt;<span style=color:#f92672>div</span>&gt;隔离scope（使用{{name}}）：
        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>isolated-directive</span> <span style=color:#a6e22e>user</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;{{user}}&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
    &lt;/<span style=color:#f92672>div</span>&gt;
&lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><h3 id=-局部-scope-属性-2>& 局部 scope 属性<a hidden class=anchor aria-hidden=true href=#-局部-scope-属性-2>#</a></h3>
<p><code>&</code> 方式提供一种途经是 directive 能在父 scope 的上下文中执行一个表达式。此表达式可以是一个 function。
比如当你写了一个 directive，当用户点击按钮时，directive 想要通知 controller，controller 无法知道 directive 中发生了什么，也许你可以通过使用 angular 中的 event 广播来做到，但是必须要在 controller 中增加一个事件监听方法。
最好的方法就是让 directive 可以通过一个父 scope 中的 function，当 directive 中有什么动作需要更新到父 scope 中的时候，可以在父 scope 上下文中执行一段代码或者一个函数。</p>
<p>如下示例在 directive 中执行父 scope 的 function。</p>
<p>js代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#34;myController&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>$scope</span>) {
    <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello world&#34;</span>;
    <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>click</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () {
        <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>random</span>();
    };
}).<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#34;isolatedDirective&#34;</span>, <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>return</span> {
        <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> {
            <span style=color:#a6e22e>action</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&amp;&#34;</span>
        },
        <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&lt;input type=&#34;button&#34; value=&#34;在directive中执行父scope定义的方法&#34; ng-click=&#34;action()&#34;/&gt;&#39;</span>
     }
})
</code></pre></div><p>html 代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html> &lt;<span style=color:#f92672>div</span>  <span style=color:#a6e22e>ng-controller</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;myController&#34;</span>&gt;
        &lt;<span style=color:#f92672>div</span>&gt;父scope：
            &lt;<span style=color:#f92672>div</span>&gt;Say：{{value}}&lt;/<span style=color:#f92672>div</span>&gt;
        &lt;/<span style=color:#f92672>div</span>&gt;
        &lt;<span style=color:#f92672>div</span>&gt;隔离scope：
            &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>isolated-directive</span> <span style=color:#a6e22e>action</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;click()&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
        &lt;/<span style=color:#f92672>div</span>&gt;
&lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><p>以上内容转自：https://blog.coding.net/blog/angularjs-directive-isolate-scope</p>
<h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2>
<p>相信关于隔离 scope 和父 scope 如何交互的三种方法已经介绍得非常清楚了，最后发现stackoverflow上面有个更加简单直接的解释，原文如下：</p>
<p>All three bindings are ways of passing data from your parent scope to your directive&rsquo;s isolated scope through the element&rsquo;s attributes:</p>
<blockquote>
<ol>
<li><code>@</code> binding is for passing strings. These strings support <code>{{}}</code> expressions for interpolated values. For example: . The interpolated expression is evaluated against directive&rsquo;s parent scope.</li>
</ol>
</blockquote>
<blockquote>
<ol start=2>
<li><code>=</code> binding is for two-way model binding. The model in parent scope is linked to the model in the directive&rsquo;s isolated scope. Changes to one model affects the other, and vice versa.</li>
</ol>
</blockquote>
<blockquote>
<ol start=3>
<li><code>&</code> binding is for passing a method into your directive&rsquo;s scope so that it can be called within your directive. The method is pre-bound to the directive&rsquo;s parent scope, and supports arguments. For example if the method is hello(name) in parent scope, then in order to execute the method from inside your directive, you must call $scope.hello({name:&lsquo;world&rsquo;})</li>
</ol>
</blockquote>
<p>I find that it&rsquo;s easier to remember these differences by referring to the scope bindings by a shorter description:</p>
<ul>
<li><code>@</code> Attribute string binding</li>
<li><code>=</code> Two-way model binding</li>
<li><code>&</code> Callback method binding</li>
</ul>
<p>The symbols also make it clearer as to what the scope variable represents inside of your directive&rsquo;s implementation:</p>
<ul>
<li><code>@</code> string</li>
<li><code>=</code> model</li>
<li><code>&</code> method</li>
</ul>
<p>In order of usefulness (for me anyways):</p>
<ul>
<li><code>=</code></li>
<li><code>@</code></li>
<li><code>&</code></li>
</ul>
<p>更多请参考API文档：https://docs.angularjs.org/api/ng/service/$compile 。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://www.xieluping.cn/tags/angularjs/>AngularJS</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://www.xieluping.cn>Null</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>