<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>JavaScript 任务和事件循环 | Null</title>
<meta name=keywords content="JavaScript">
<meta name=description content="js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。
First 首先来看下面一段代码：
console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'
执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：
function a() { console.log('a'); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?
console.log(&#34;sync&#34;); $.on('button', 'click', function onClick() { setTimeout(function timer() { console.log('You clicked the button!'); }, 2000); }); setTimeout(function timeout() { console.log(&#34;Click the button!">
<meta name=author content>
<link rel=canonical href=https://www.xieluping.cn/post/event-loop/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.xieluping.cn/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.xieluping.cn/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://www.xieluping.cn/favicon-32x32.png>
<link rel=apple-touch-icon href=https://www.xieluping.cn/apple-touch-icon.png>
<link rel=mask-icon href=https://www.xieluping.cn/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<link rel=stylesheet href=https://www.xieluping.cn/css/style.css><meta property="og:title" content="JavaScript 任务和事件循环">
<meta property="og:description" content="js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。
First 首先来看下面一段代码：
console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'
执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：
function a() { console.log('a'); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?
console.log(&#34;sync&#34;); $.on('button', 'click', function onClick() { setTimeout(function timer() { console.log('You clicked the button!'); }, 2000); }); setTimeout(function timeout() { console.log(&#34;Click the button!">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.xieluping.cn/post/event-loop/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2018-03-08T17:33:31+08:00">
<meta property="article:modified_time" content="2018-03-08T17:33:31+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="JavaScript 任务和事件循环">
<meta name=twitter:description content="js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。
First 首先来看下面一段代码：
console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'
执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：
function a() { console.log('a'); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?
console.log(&#34;sync&#34;); $.on('button', 'click', function onClick() { setTimeout(function timer() { console.log('You clicked the button!'); }, 2000); }); setTimeout(function timeout() { console.log(&#34;Click the button!">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.xieluping.cn/post/"},{"@type":"ListItem","position":3,"name":"JavaScript 任务和事件循环","item":"https://www.xieluping.cn/post/event-loop/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript 任务和事件循环","name":"JavaScript 任务和事件循环","description":"js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。\nFirst 首先来看下面一段代码：\nconsole.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); Promise.resolve().then(function() { console.log(\u0026#39;promise1\u0026#39;); }).then(function() { console.log(\u0026#39;promise2\u0026#39;); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'\n执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：\nfunction a() { console.log(\u0026#39;a\u0026#39;); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?\nconsole.log(\u0026#34;sync\u0026#34;); $.on(\u0026#39;button\u0026#39;, \u0026#39;click\u0026#39;, function onClick() { setTimeout(function timer() { console.log(\u0026#39;You clicked the button!\u0026#39;); }, 2000); }); setTimeout(function timeout() { console.log(\u0026#34;Click the button!","keywords":["JavaScript"],"articleBody":"js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。\nFirst 首先来看下面一段代码：\nconsole.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); 这段代码打印的结果是：'script start', 'promise1', 'promise2', 'setTimeout'\n执行栈 js引擎开始运行代码的时候，会将代码压入执行栈进行执行：\nfunction a() { console.log('a'); } function b() { a(); } function c() { b(); } c(); 当代码被解析后，函数会依次被压入到栈中 当函数c执行完，开始出栈 事件循环 当执行栈中出现异步代码会怎么样?\nconsole.log(\"sync\"); $.on('button', 'click', function onClick() { setTimeout(function timer() { console.log('You clicked the button!'); }, 2000); }); setTimeout(function timeout() { console.log(\"Click the button!\"); }, 5000); 当浏览器在执行栈执行的时候，发现有异步任务之后，会交给 webapi 去维护，而执行栈则继续执行后面的任务 同样，setTimeout 同样会被添加到 webapi 中 当上面的setTimeout执行结束后并不是直接进入执行栈，而是进入任务队列，等待执行栈为空，setTimeout的可执行函数，被从回调队列中取出，放入了执行栈执行。这个过程就叫做事件循环。\n 推荐个JS执行的可视化工具 loupe\n 任务队列 回头再介绍下任务队列，上面的例子中 webapi 处理完 setTimeout 后，就会直接将回调函数放入任务队列中，等待执行。这个过程必须等待执行栈为空已经前面的任务执行完。例如：\nconsole.log(1) // snippet1 setTimeout(function() { // snippet2  console.log(2); }, 100) setTimeout(function() { // snippet3  console.log(3); setTimeout(function() { // snippet4  console.log(4) }, 0) }, 0) console.log(5) // snippet5 // let start = +new Date; // while(start + 2000  +new Date){} 这段代码的输出顺序是1, 5, 3, 4, 2。 这段代码的执行过程是：\n snippet1 push 到执行栈，执行完并清空执行栈 snippet2 交给 Web Apis，100ms 后将回调 push 到任务队列 snippet3 交给 Web Apis，0ms 后将回调 push 到任务队列 snippet5 的回调 push 到执行栈，执行完并清空执行栈 snippet3 的回调 push 到执行栈，执行完并清空执行栈，同时将 snippet4 交给 Web Apis，0ms 后将回调 push 到任务队列 snippet4 的回调 push 到执行栈，执行完并清空执行栈 如果 snippet2 已经在任务队列中，将 snippet2 的回调 push 到执行栈，执行完并清空执行栈  任务 以上说的其实都是所谓的“宏任务”，主要包括整体代码 script，setTimeout，setInterval。\n微任务 如果将之前的代码改下：\nconsole.log(1) // snippet1 Promise.resolve().then(function() { // snippet2  console.log(2); }) setTimeout(function() { // snippet3  console.log(3); setTimeout(function() { // snippet4  console.log(4) }, 0) }, 0) console.log(5) // snippet5 这段代码的输出顺序是1, 5, 2, 3, 4。 这是因为 promise 的 then 方法，被认为是在微任务队列当中。 microtask 通常来说就是需要在当前 task 执行结束后立即执行的任务，例如需要对一系列的任务做出回应，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。microtask 任务队列是一个与 task 任务队列相互独立的队列，microtask 任务将会在每一个 task 任务执行结束之后执行。每一个 task 中产生的 microtask 都将会添加到 microtask 队列中，microtask 中产生的 microtask 将会添加至当前队列的尾部，并且 microtask 会按序的处理完队列中的所有任务。microtask 类型的任务目前包括了 MutationObserver 以及 Promise 的回调函数和 node 中的 process.nextTick。\n这段代码的执行过程是：\n snippet1 push 到执行栈，执行完并清空执行栈 snippet2 的回调 push 到 microtask 队列中 snippet3 交给 Web Apis，0ms 后将回调 push 到 marcotask 队列 snippet5 的回调 push 到执行栈，执行完并清空执行栈 script task 执行完后，将 snippet2 中的回调从 microtask 队列取出，push 到执行栈，执行完并清空执行栈 snippet3 的回调 push 到执行栈，执行完并清空执行栈，同时将 snippet4 交给 Web Apis，0ms 后将回调 push 到任务队列 snippet4 的回调 push 到执行栈，执行完并清空执行栈  One more question 如果有下面一段代码：\ndiv class=\"outer\" div class=\"inner\"div div var outer = document.querySelector('.outer'); var inner = document.querySelector('.inner'); new MutationObserver(function() { console.log('mutate'); }).observe(outer, { attributes: true }); function onClick() { console.log('click'); setTimeout(function() { console.log('timeout'); }, 0); Promise.resolve().then(function() { console.log('promise'); }); outer.setAttribute('data-random', Math.random()); } inner.addEventListener('click', onClick); outer.addEventListener('click', onClick); // inner.click(); 在这里不同的浏览器可能会有不同的结果。\n   Chrome FireFox Safari Edge     click click click click   promise mutate mutate click   mutate click click mutate   click mutate mutate timeout   promise timeout promise promise   mutate promise promise timeout   timeout promise timeout promise   timeout timeout timeout     按照上面的推导 Chrome 的输出是正确的。\n 通过上面的例子可以测试出，FireFox 和 Safari 能够正确的执行 microtask 队列，这一点可以通过 MutationObserver 的表现中看出，不过 Promise 被添加至事件队列中的方式好像有些不同。 这一点也是能够理解的，由于 jobs 和 microtasks 的关系以及概念目前还比较模糊，不过人们都普遍的期望他们都能够在两个事件监听器之间执行。这里有 FireFox 和 Safari 的 BUG 记录。（目前 Safari 已经修复了这一 BUG） 在 Edge 中我们可以明显的看出其压入 Promise 的方式是错误的，同时其执行 microtask 队列的方式也不正确，它没有在两个事件监听器之间执行，反而是在所有的事件监听器之后执行，所以才会只输出了一次 mutate 。Edge bug ticket （目前已修复）\n 加入我们现在取消上段代码中最后一行的注释，使用模拟点击输出的是什么呢？\n   Chrome FireFox Safari Edge     click click click click   click click click click   promise mutate mutate mutate   mutate timeout promise timeout   promise promise promise promise   timeout promise timeout timeout   timeout timeout timeout promise    在确定上面答案前先看一个小例子：\nbutton id=\"btn\"click mebutton let btn = document.getElementById('btn'); console.log(1); btn.onclick = function() { console.log(2) } console.log(3); 很明显输出顺序是：1, 3, 2。 但是如果是直接调用 click 方法：\nlet btn = document.getElementById('btn'); console.log(1); btn.onclick = function() { console.log(2) } btn.click(); console.log(3); 输出的结果是：1, 2, 3。 原因是我们调用 .click()，使得事件监听器的回调函数和当前运行的脚本同步执行而不再是异步。\n同理在之前的例子中由于我们调用 click()，使得事件监听器的回调函数和当前运行的脚本同步执行，所以当前脚本的执行栈会一直压在 JS 执行栈当中（简单来说就是click的回调并没有加入任务队列中，而是直接执行了）。所以在这个 demo 中 microtask 不会在每一个 click 事件之后执行，而是在两个 click 事件执行完成之后执行。所以在这里我们可以再次的对 microtask 的检查点进行定义：当执行栈(JS Stack)为空时，执行一次 microtask 检查点。这也确保了无论是一个 task 还是一个 microtask 在执行完毕之后都会生成一个 microtask 检查点，也保证了 microtask 队列能够一次性执行完毕。\n","wordCount":"516","inLanguage":"en","datePublished":"2018-03-08T17:33:31+08:00","dateModified":"2018-03-08T17:33:31+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.xieluping.cn/post/event-loop/"},"publisher":{"@type":"Organization","name":"Null","logo":{"@type":"ImageObject","url":"https://www.xieluping.cn/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.xieluping.cn accesskey=h title="Null (Alt + H)">Null</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.xieluping.cn/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.xieluping.cn/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
JavaScript 任务和事件循环
</h1>
<div class=post-meta>March 8, 2018
</div>
</header>
<div class=post-content><p>js是单线程的，处理任务是一件接着一件处理，所以如果一个任务需要处理很久的话，后面的任务就会被阻塞，所以 JS 通过 Event Loop 事件循环的方式解决了这个问题。</p>
<h2 id=first>First<a hidden class=anchor aria-hidden=true href=#first>#</a></h2>
<p>首先来看下面一段代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;script start&#39;</span>);

<span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;setTimeout&#39;</span>);
}, <span style=color:#ae81ff>0</span>);

Promise.<span style=color:#a6e22e>resolve</span>().<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span>() {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;promise1&#39;</span>);
}).<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span>() {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;promise2&#39;</span>);
});
</code></pre></div><p>这段代码打印的结果是：<code>'script start'</code>, <code>'promise1'</code>, <code>'promise2'</code>, <code>'setTimeout'</code></p>
<h2 id=执行栈>执行栈<a hidden class=anchor aria-hidden=true href=#执行栈>#</a></h2>
<p>js引擎开始运行代码的时候，会将代码压入执行栈进行执行：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>a</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;a&#39;</span>);
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>b</span>() {
    <span style=color:#a6e22e>a</span>();
}
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>c</span>() {
    <span style=color:#a6e22e>b</span>();
}
<span style=color:#a6e22e>c</span>();
</code></pre></div><p>当代码被解析后，函数会依次被压入到栈中
<img loading=lazy src=https://cdn.xieluping.cn/images/ntfq72ljf1l.png alt>
</p>
<p>当函数c执行完，开始出栈
<img loading=lazy src=https://cdn.xieluping.cn/images/98jgwu48as4.png alt>
</p>
<h2 id=事件循环>事件循环<a hidden class=anchor aria-hidden=true href=#事件循环>#</a></h2>
<p>当执行栈中出现异步代码会怎么样?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;sync&#34;</span>);

<span style=color:#a6e22e>$</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;button&#39;</span>, <span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onClick</span>() {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>timer</span>() {
        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;You clicked the button!&#39;</span>);    
    }, <span style=color:#ae81ff>2000</span>);
});

<span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>timeout</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Click the button!&#34;</span>);
}, <span style=color:#ae81ff>5000</span>);

</code></pre></div><p>当浏览器在执行栈执行的时候，发现有异步任务之后，会交给 webapi 去维护，而执行栈则继续执行后面的任务
<img loading=lazy src=https://cdn.xieluping.cn/images/s8c5yx7ia5r.png alt>
</p>
<p>同样，setTimeout 同样会被添加到 webapi 中
<img loading=lazy src=https://cdn.xieluping.cn/images/ugloyynx3m.png alt>
</p>
<p>当上面的setTimeout执行结束后并不是直接进入执行栈，而是进入任务队列，等待执行栈为空，setTimeout的可执行函数，被从回调队列中取出，放入了执行栈执行。这个过程就叫做<code>事件循环</code>。</p>
<blockquote>
<p>推荐个JS执行的可视化工具 <a href=http://latentflip.com/loupe/>loupe</a></p>
</blockquote>
<h2 id=任务队列>任务队列<a hidden class=anchor aria-hidden=true href=#任务队列>#</a></h2>
<p>回头再介绍下任务队列，上面的例子中 webapi 处理完 setTimeout 后，就会直接将回调函数放入任务队列中，等待执行。这个过程必须等待执行栈为空已经前面的任务执行完。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>1</span>)  <span style=color:#75715e>// snippet1
</span><span style=color:#75715e></span><span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() {  <span style=color:#75715e>// snippet2
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>2</span>);
}, <span style=color:#ae81ff>100</span>)
<span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() { <span style=color:#75715e>// snippet3
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>3</span>);
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() { <span style=color:#75715e>// snippet4
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>4</span>)
    }, <span style=color:#ae81ff>0</span>)
}, <span style=color:#ae81ff>0</span>)
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>5</span>) <span style=color:#75715e>// snippet5
</span><span style=color:#75715e>// let start = +new Date;
</span><span style=color:#75715e>// while(start + 2000 &gt; +new Date){}
</span></code></pre></div><p>这段代码的输出顺序是<code>1</code>, <code>5</code>, <code>3</code>, <code>4</code>, <code>2</code>。
这段代码的执行过程是：</p>
<ol>
<li>snippet1 push 到执行栈，执行完并清空执行栈</li>
<li>snippet2 交给 Web Apis，100ms 后将回调 push 到任务队列</li>
<li>snippet3 交给 Web Apis，0ms 后将回调 push 到任务队列</li>
<li>snippet5 的回调 push 到执行栈，执行完并清空执行栈</li>
<li>snippet3 的回调 push 到执行栈，执行完并清空执行栈，同时将 snippet4 交给 Web Apis，0ms 后将回调 push 到任务队列</li>
<li>snippet4 的回调 push 到执行栈，执行完并清空执行栈</li>
<li>如果 snippet2 已经在任务队列中，将 snippet2 的回调 push 到执行栈，执行完并清空执行栈</li>
</ol>
<h3 id=任务>任务<a hidden class=anchor aria-hidden=true href=#任务>#</a></h3>
<p>以上说的其实都是所谓的“宏任务”，主要包括整体代码 <code>script</code>，<code>setTimeout</code>，<code>setInterval</code>。</p>
<h3 id=微任务>微任务<a hidden class=anchor aria-hidden=true href=#微任务>#</a></h3>
<p>如果将之前的代码改下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>1</span>)  <span style=color:#75715e>// snippet1
</span><span style=color:#75715e></span>Promise.<span style=color:#a6e22e>resolve</span>().<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span>() {  <span style=color:#75715e>// snippet2
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>2</span>);
})
<span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() { <span style=color:#75715e>// snippet3
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>3</span>);
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() { <span style=color:#75715e>// snippet4
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>4</span>)
    }, <span style=color:#ae81ff>0</span>)
}, <span style=color:#ae81ff>0</span>)
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>5</span>) <span style=color:#75715e>// snippet5
</span></code></pre></div><p>这段代码的输出顺序是<code>1</code>, <code>5</code>, <code>2</code>, <code>3</code>, <code>4</code>。
这是因为 promise 的 then 方法，被认为是在微任务队列当中。
microtask 通常来说就是需要在当前 task 执行结束后立即执行的任务，例如需要对一系列的任务做出回应，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。microtask 任务队列是一个与 task 任务队列相互独立的队列，microtask 任务将会在每一个 task 任务执行结束之后执行。每一个 task 中产生的 microtask 都将会添加到 microtask 队列中，microtask 中产生的 microtask 将会添加至当前队列的尾部，并且 microtask 会按序的处理完队列中的所有任务。microtask 类型的任务目前包括了 MutationObserver 以及 Promise 的回调函数和 node 中的 process.nextTick。</p>
<p>这段代码的执行过程是：</p>
<ol>
<li>snippet1 push 到执行栈，执行完并清空执行栈</li>
<li>snippet2 的回调 push 到 microtask 队列中</li>
<li>snippet3 交给 Web Apis，0ms 后将回调 push 到 marcotask 队列</li>
<li>snippet5 的回调 push 到执行栈，执行完并清空执行栈</li>
<li>script task 执行完后，将 snippet2 中的回调从 microtask 队列取出，push 到执行栈，执行完并清空执行栈</li>
<li>snippet3 的回调 push 到执行栈，执行完并清空执行栈，同时将 snippet4 交给 Web Apis，0ms 后将回调 push 到任务队列</li>
<li>snippet4 的回调 push 到执行栈，执行完并清空执行栈</li>
</ol>
<h2 id=one-more-question>One more question<a hidden class=anchor aria-hidden=true href=#one-more-question>#</a></h2>
<p>如果有下面一段代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;outer&#34;</span>&gt;
  &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;inner&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
&lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>outer</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;.outer&#39;</span>);
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inner</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;.inner&#39;</span>);

<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MutationObserver</span>(<span style=color:#66d9ef>function</span>() {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;mutate&#39;</span>);
}).<span style=color:#a6e22e>observe</span>(<span style=color:#a6e22e>outer</span>, {
  <span style=color:#a6e22e>attributes</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
});

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onClick</span>() {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;click&#39;</span>);

  <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;timeout&#39;</span>);
  }, <span style=color:#ae81ff>0</span>);

  Promise.<span style=color:#a6e22e>resolve</span>().<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;promise&#39;</span>);
  });

  <span style=color:#a6e22e>outer</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#39;data-random&#39;</span>, Math.<span style=color:#a6e22e>random</span>());
}

<span style=color:#a6e22e>inner</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#a6e22e>onClick</span>);
<span style=color:#a6e22e>outer</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#a6e22e>onClick</span>);

<span style=color:#75715e>// inner.click();
</span></code></pre></div><p>在这里不同的浏览器可能会有不同的结果。</p>
<table>
<thead>
<tr>
<th style=text-align:left>Chrome</th>
<th style=text-align:left>FireFox</th>
<th style=text-align:left>Safari</th>
<th style=text-align:left>Edge</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
</tr>
<tr>
<td style=text-align:left>promise</td>
<td style=text-align:left>mutate</td>
<td style=text-align:left>mutate</td>
<td style=text-align:left>click</td>
</tr>
<tr>
<td style=text-align:left>mutate</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>mutate</td>
</tr>
<tr>
<td style=text-align:left>click</td>
<td style=text-align:left>mutate</td>
<td style=text-align:left>mutate</td>
<td style=text-align:left>timeout</td>
</tr>
<tr>
<td style=text-align:left>promise</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>promise</td>
</tr>
<tr>
<td style=text-align:left>mutate</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>timeout</td>
</tr>
<tr>
<td style=text-align:left>timeout</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>promise</td>
</tr>
<tr>
<td style=text-align:left>timeout</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left></td>
</tr>
</tbody>
</table>
<p>按照上面的推导 Chrome 的输出是正确的。</p>
<blockquote>
<p>通过上面的例子可以测试出，FireFox 和 Safari 能够正确的执行 microtask 队列，这一点可以通过 MutationObserver 的表现中看出，不过 Promise 被添加至事件队列中的方式好像有些不同。 这一点也是能够理解的，由于 jobs 和 microtasks 的关系以及概念目前还比较模糊，不过人们都普遍的期望他们都能够在两个事件监听器之间执行。这里有 FireFox 和 Safari 的 BUG 记录。（目前 Safari 已经修复了这一 BUG）
在 Edge 中我们可以明显的看出其压入 Promise 的方式是错误的，同时其执行 microtask 队列的方式也不正确，它没有在两个事件监听器之间执行，反而是在所有的事件监听器之后执行，所以才会只输出了一次 mutate 。Edge bug ticket （目前已修复）</p>
</blockquote>
<p>加入我们现在取消上段代码中最后一行的注释，使用模拟点击输出的是什么呢？</p>
<table>
<thead>
<tr>
<th style=text-align:left>Chrome</th>
<th style=text-align:left>FireFox</th>
<th style=text-align:left>Safari</th>
<th style=text-align:left>Edge</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
</tr>
<tr>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
<td style=text-align:left>click</td>
</tr>
<tr>
<td style=text-align:left>promise</td>
<td style=text-align:left>mutate</td>
<td style=text-align:left>mutate</td>
<td style=text-align:left>mutate</td>
</tr>
<tr>
<td style=text-align:left>mutate</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>timeout</td>
</tr>
<tr>
<td style=text-align:left>promise</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>promise</td>
</tr>
<tr>
<td style=text-align:left>timeout</td>
<td style=text-align:left>promise</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>timeout</td>
</tr>
<tr>
<td style=text-align:left>timeout</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>timeout</td>
<td style=text-align:left>promise</td>
</tr>
</tbody>
</table>
<p>在确定上面答案前先看一个小例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;btn&#34;</span>&gt;click me&lt;/<span style=color:#f92672>button</span>&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>btn</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;btn&#39;</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>1</span>);
<span style=color:#a6e22e>btn</span>.<span style=color:#a6e22e>onclick</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>2</span>)
}
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>3</span>);
</code></pre></div><p>很明显输出顺序是：<code>1</code>, <code>3</code>, <code>2</code>。
但是如果是直接调用 click 方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>btn</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;btn&#39;</span>);

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>1</span>);
<span style=color:#a6e22e>btn</span>.<span style=color:#a6e22e>onclick</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>2</span>)
}
<span style=color:#a6e22e>btn</span>.<span style=color:#a6e22e>click</span>();
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>3</span>);
</code></pre></div><p>输出的结果是：<code>1</code>, <code>2</code>, <code>3</code>。
原因是我们调用 .click()，使得事件监听器的回调函数和当前运行的脚本同步执行而不再是异步。</p>
<p>同理在之前的例子中由于我们调用 click()，使得事件监听器的回调函数和当前运行的脚本同步执行，所以当前脚本的执行栈会一直压在 JS 执行栈当中（简单来说就是click的回调并没有加入任务队列中，而是直接执行了）。所以在这个 demo 中 microtask 不会在每一个 click 事件之后执行，而是在两个 click 事件执行完成之后执行。所以在这里我们可以再次的对 microtask 的检查点进行定义：当执行栈(JS Stack)为空时，执行一次 microtask 检查点。这也确保了无论是一个 task 还是一个 microtask 在执行完毕之后都会生成一个 microtask 检查点，也保证了 microtask 队列能够一次性执行完毕。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://www.xieluping.cn/tags/javascript/>JavaScript</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://www.xieluping.cn>Null</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>