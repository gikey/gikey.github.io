<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>JavaScript instanceof 操作符 | Null</title>
<meta name=keywords content="JavaScript">
<meta name=description content="instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 &ldquo;object&rdquo;。例如：
var arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：
var arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ?">
<meta name=author content>
<link rel=canonical href=https://gikey.github.io/post/instanceof/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.6cba0d81b5f3f42bb578d49f402ba4175aa72b43def148780b8ad714c957c6f5.css integrity="sha256-bLoNgbXz9Cu1eNSfQCukF1qnK0Pe8Uh4C4rXFMlXxvU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gikey.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://gikey.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://gikey.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://gikey.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://gikey.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<link rel=stylesheet href=https://gikey.github.io/css/style.css><meta property="og:title" content="JavaScript instanceof 操作符">
<meta property="og:description" content="instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 &ldquo;object&rdquo;。例如：
var arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：
var arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://gikey.github.io/post/instanceof/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2017-08-18T12:51:54+08:00">
<meta property="article:modified_time" content="2017-08-18T12:51:54+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="JavaScript instanceof 操作符">
<meta name=twitter:description content="instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 &ldquo;object&rdquo;。例如：
var arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：
var arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ?">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://gikey.github.io/post/"},{"@type":"ListItem","position":3,"name":"JavaScript instanceof 操作符","item":"https://gikey.github.io/post/instanceof/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript instanceof 操作符","name":"JavaScript instanceof 操作符","description":"instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 \u0026ldquo;object\u0026rdquo;。例如：\nvar arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：\nvar arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ?","keywords":["JavaScript"],"articleBody":"instanceof 简介 在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。例如：\nvar arr = new Array(); console.log( typeof arr ); // object 如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：\nvar arr = new Array(); var Fn = function() {}; var foo = new Fn(); console.log( arr instanceof Array ); // true console.log( arr instanceof Object ); // true console.log( foo instanceof Fn); // true console.log( foo instanceof Function ); // false console.log( foo instanceof Object ); // true Function instanceof Function ? console.log( String instanceof String ); console.log( Function instanceof Function ); console.log( Function instanceof Object ); console.log( Object instanceof Function ); console.log( Object instanceof Object ); 要解释这个问题就需要了解 1.JavaScript 语言规范中是如何定义 instanceof 运算符的，2.JavaScript 原型继承机制。\ninstanceof 运算符的定义 在 ECMAScript-262 中 instanceof 运算符的定义是这样的:\n 12.9.4 Runtime Semantics: InstanceofOperator(O, C) The abstract operation InstanceofOperator(O, C) implements the generic algorithm for determining if an object O inherits from the inheritance path defined by constructor C. This abstract operation performs the following steps:\n If Type(C) is not Object, throw a TypeError exception. Let instOfHandler be GetMethod(C,@@hasInstance). ReturnIfAbrupt(instOfHandler). If instOfHandler is not undefined, then a. Return ToBoolean(Call(instOfHandler, C, «O»)). If IsCallable(C) is false, throw a TypeError exception. Return OrdinaryHasInstance(C, O). NOTE Steps 5 and 6 provide compatibility with previous editions of ECMAScript that did not use a @@hasInstance method to define the instanceof operator semantics. If a function object does not define or inherit @@hasInstance it uses the default instanceof semantics.    7.3.19 OrdinaryHasInstance (C, O) The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object O inherits from the instance object inheritance path provided by constructor C. This abstract operation performs the following steps:\n If IsCallable(C) is false, return false. If C has a [[BoundTargetFunction]] internal slot, then a. Let BC be the value of C’s [[BoundTargetFunction]] internal slot. b. Return InstanceofOperator(O,BC) (see 12.9.4). If Type(O) is not Object, return false. Let P be Get(C, “prototype”). ReturnIfAbrupt(P). If Type(P) is not Object, throw a TypeError exception. Repeat a. Let O be O.[[GetPrototypeOf]](). b. ReturnIfAbrupt(O). c. If O is null, return false. d. If SameValue(P, O) is true, return true.   官网的定义非常晦涩，上面的翻译成代码大概就是：\nfunction instanceOf( L, R ) { //L 表示左表达式，R 表示右表达式  var P = R.prototype; // 取 R 的显示原型  L = L.__proto__; // 取 L 的隐式原型  while ( true ) { if ( L === null ) return false; if ( P === L ) return true; L = L.__proto__; } } 再直接点的表达就是 instanceof 会一直在 obj 的原型链上查找，直到找到右边那个构造函数的 prototype 属性，或者为 null 的时候才停止。 类似：\nobj.__proto__.__proto__ ... = Obj.prototype obj 会一直沿着隐式原型链 __proto__ 向上查找直到 obj.__proto__.__proto__ ...... === Obj.prototype 为止，如果找到则返回 true，也就是 obj 为 Obj 的一个实例。否则返回 false，obj 不是 Obj 的实例。\nJavaScript 原型继承机制 原型与原型链 在 JavaScript 每个函数都有一个 prototype 属性，该属性存储的就是原型对象。JavaScript 构造函数的继承都是通过 prototype 属性， 真正的原型链的实现是通过 __proto__ 实现的，__proto__其实是指向‘父类’的 prototype 属性。例如：\nvar Foo = function() {} var foo = new Foo; console.log(foo.__proto__ === Foo.prototype) // true console.log(Foo.__proto__ === Function.prototype) // true 原型继承 JavaScript 是单继承的，Object.prototype 是原型链的顶端，所有对象从它继承了包括 valueOf、toString 等等方法和属性。Object 本身是构造函数，继承了 Function.prototype。 Function 也是对象，继承了 Object.prototype。\n下面我们推导下之前的两个例子，其他的可以自行推倒。\n Object instanceof Object  ObjectL = Object, ObjectR = Object; R = ObjectR.prototype = Object.prototype L = ObjectL.__proto__ = Function.prototype R != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype R == L // 返回 true  String instanceof String  StringL = String, StringR = String; R = StringR.prototype = String.prototype L = StringL.__proto__ = Function.prototype R != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype R != L // 接着查找 L = Object.prototype.__proto__ = null // 返回 false 一切皆对象？ 常常说 JavaScript 中一切皆对象，那么就有这样一个问题了：\n'string'.__proto__ === String.prototype // true 'string' instanceof String // false 按照上面的推导，'string' instanceof String 应该为 true，但是我们得到的却是 false。 其实问题的关键在于：\nconsole.log(typeof 'string'); // string ‘string’ 并不是一个 object 对象，MDN 上对 instanceof 的定义是：\n The instanceof operator tests whether an object in its prototype chain has the prototype property of a constructor.\n 这样又有一个问题了，既然字符串不是对象那为什么有对象才有的属性和方法呢？\nvar s1 = \"string\"; var s2 = s1.substring(2); 为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型: Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。\n《JavaScript高级程序设计》中是这么解释的：\n 上面的例子其实当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成： (1) 创建 String 类型的一个实例; (2) 在实例上调用指定的方法; (3) 销毁这个实例。\n 可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。\nvar s1 = new String(\"some text\"); var s2 = s1.substring(2); s1 = null; 《Javascript权威指南》里说：\n 其实（包装对象）在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样的。\n 这样 Boolean、Number 是一样的逻辑。还剩下两种基本类型：null 和 undefined。\nundefined 当我们对变量只声明没有初始化时，输出为 undefined，typeof undefined 返回的是 undefined 也不是 object 类型，所以 undefined 并不是任何对象的实例。\nnull 表示的是空对象，虽然 typeof null 是 object，但是 null 和 undefined 一样并没有任何属性和方法，在 instanceof 定义中也有判断，如果类型不是 object（这个类型判断并不是跟 typeof 返回值一样），就返回 false。 ","wordCount":"685","inLanguage":"en","datePublished":"2017-08-18T12:51:54+08:00","dateModified":"2017-08-18T12:51:54+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://gikey.github.io/post/instanceof/"},"publisher":{"@type":"Organization","name":"Null","logo":{"@type":"ImageObject","url":"https://gikey.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://gikey.github.io accesskey=h title="Null (Alt + H)">Null</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://gikey.github.io/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://gikey.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://gikey.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://gikey.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
JavaScript instanceof 操作符
</h1>
<div class=post-meta>August 18, 2017
</div>
</header>
<div class=post-content><h2 id=instanceof-简介>instanceof 简介<a hidden class=anchor aria-hidden=true href=#instanceof-简介>#</a></h2>
<p>在 JavaScript 中，判断一个变量的类型通常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 &ldquo;object&rdquo;。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Array();
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>arr</span> ); <span style=color:#75715e>// object
</span></code></pre></div><p>如果想要确定原型和实例之间的关系就需要用到 instanceof 操作符， 例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Array();
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Fn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {};
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Fn</span>();
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>arr</span> <span style=color:#66d9ef>instanceof</span> Array ); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>arr</span> <span style=color:#66d9ef>instanceof</span> Object ); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>foo</span> <span style=color:#66d9ef>instanceof</span> <span style=color:#a6e22e>Fn</span>); <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>foo</span> <span style=color:#66d9ef>instanceof</span> Function ); <span style=color:#75715e>// false
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>foo</span> <span style=color:#66d9ef>instanceof</span> Object ); <span style=color:#75715e>// true
</span></code></pre></div><h2 id=function-instanceof-function->Function instanceof Function ?<a hidden class=anchor aria-hidden=true href=#function-instanceof-function->#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( String <span style=color:#66d9ef>instanceof</span> String );
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( Function <span style=color:#66d9ef>instanceof</span> Function );
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( Function <span style=color:#66d9ef>instanceof</span> Object );
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( Object <span style=color:#66d9ef>instanceof</span> Function );
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( Object <span style=color:#66d9ef>instanceof</span> Object );
</code></pre></div><p>要解释这个问题就需要了解 1.JavaScript 语言规范中是如何定义 instanceof 运算符的，2.JavaScript 原型继承机制。</p>
<h2 id=instanceof-运算符的定义httpwwwecma-internationalorgecma-26260sec-instanceofoperator><a href=http://www.ecma-international.org/ecma-262/6.0/#sec-instanceofoperator>instanceof 运算符的定义</a><a hidden class=anchor aria-hidden=true href=#instanceof-运算符的定义httpwwwecma-internationalorgecma-26260sec-instanceofoperator>#</a></h2>
<p>在 ECMAScript-262 中 instanceof 运算符的定义是这样的:</p>
<blockquote>
<p>12.9.4 Runtime Semantics: InstanceofOperator(O, C)
The abstract operation InstanceofOperator(O, C) implements the generic algorithm for determining if an object O inherits from the inheritance path defined by constructor C. This abstract operation performs the following steps:</p>
<ol>
<li>If Type(C) is not Object, throw a TypeError exception.</li>
<li>Let instOfHandler be GetMethod(C,@@hasInstance).</li>
<li>ReturnIfAbrupt(instOfHandler).</li>
<li>If instOfHandler is not undefined, then
a. Return ToBoolean(Call(instOfHandler, C, «O»)).</li>
<li>If IsCallable(C) is false, throw a TypeError exception.</li>
<li>Return OrdinaryHasInstance(C, O).
NOTE Steps 5 and 6 provide compatibility with previous editions of ECMAScript that did not use a @@hasInstance method to define the instanceof operator semantics. If a function object does not define or inherit @@hasInstance it uses the default instanceof semantics.</li>
</ol>
</blockquote>
<blockquote>
<p>7.3.19 OrdinaryHasInstance (C, O)
The abstract operation OrdinaryHasInstance implements the default algorithm for determining if an object O inherits from the instance object inheritance path provided by constructor C. This abstract operation performs the following steps:</p>
<ol>
<li>If IsCallable(C) is false, return false.</li>
<li>If C has a [[BoundTargetFunction]] internal slot, then
a. Let BC be the value of C’s [[BoundTargetFunction]] internal slot.
b. Return InstanceofOperator(O,BC) (see 12.9.4).</li>
<li>If Type(O) is not Object, return false.</li>
<li>Let P be Get(C, &ldquo;prototype&rdquo;).</li>
<li>ReturnIfAbrupt(P).</li>
<li>If Type(P) is not Object, throw a TypeError exception.</li>
<li>Repeat
a. Let O be <code>O.[[GetPrototypeOf]]()</code>.
b. ReturnIfAbrupt(O).
c. If O is null, return false.
d. If SameValue(P, O) is true, return true.</li>
</ol>
</blockquote>
<p>官网的定义非常晦涩，上面的翻译成代码大概就是：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>instanceOf</span>( <span style=color:#a6e22e>L</span>, <span style=color:#a6e22e>R</span> ) { <span style=color:#75715e>//L 表示左表达式，R 表示右表达式
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>P</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>R</span>.<span style=color:#a6e22e>prototype</span>; <span style=color:#75715e>// 取 R 的显示原型
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>L</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span>; <span style=color:#75715e>// 取 L 的隐式原型
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> ( <span style=color:#66d9ef>true</span> ) { 
        <span style=color:#66d9ef>if</span> ( <span style=color:#a6e22e>L</span> <span style=color:#f92672>===</span> <span style=color:#66d9ef>null</span> ) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
        <span style=color:#66d9ef>if</span> ( <span style=color:#a6e22e>P</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>L</span> ) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>; 
        <span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>L</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span>; 
    } 
}
</code></pre></div><p>再直接点的表达就是 instanceof 会一直在 obj 的原型链上查找，直到找到右边那个构造函数的 prototype 属性，或者为 null 的时候才停止。
类似：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>obj</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> ... <span style=color:#f92672>=</span> <span style=color:#a6e22e>Obj</span>.<span style=color:#a6e22e>prototype</span>
</code></pre></div><p>obj 会一直沿着隐式原型链 <code>__proto__</code> 向上查找直到 <code>obj.__proto__.__proto__ ...... === Obj.prototype</code> 为止，如果找到则返回 true，也就是 obj 为 Obj 的一个实例。否则返回 false，obj 不是 Obj 的实例。</p>
<h2 id=javascript-原型继承机制>JavaScript 原型继承机制<a hidden class=anchor aria-hidden=true href=#javascript-原型继承机制>#</a></h2>
<h3 id=原型与原型链>原型与原型链<a hidden class=anchor aria-hidden=true href=#原型与原型链>#</a></h3>
<p>在 JavaScript 每个函数都有一个 prototype 属性，该属性存储的就是原型对象。JavaScript 构造函数的继承都是通过 prototype 属性， 真正的原型链的实现是通过 <code>__proto__</code> 实现的，<code>__proto__</code>其实是指向‘父类’的 prototype 属性。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Foo</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {}
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>foo</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Foo</span>;
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>Foo</span>.<span style=color:#a6e22e>prototype</span>) <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>Foo</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>===</span> Function.<span style=color:#a6e22e>prototype</span>) <span style=color:#75715e>// true
</span></code></pre></div><h3 id=原型继承>原型继承<a hidden class=anchor aria-hidden=true href=#原型继承>#</a></h3>
<p>JavaScript 是单继承的，Object.prototype 是原型链的顶端，所有对象从它继承了包括 valueOf、toString 等等方法和属性。Object 本身是构造函数，继承了 Function.prototype。 Function 也是对象，继承了 Object.prototype。</p>
<p><img loading=lazy src=https://cdn.xieluping.cn/images/n448lo5bi6c3w5no6iggb9.jpg alt>
</p>
<p>下面我们推导下之前的两个例子，其他的可以自行推倒。</p>
<ul>
<li>Object instanceof Object</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>ObjectL</span> <span style=color:#f92672>=</span> Object, <span style=color:#a6e22e>ObjectR</span> <span style=color:#f92672>=</span> Object; 

<span style=color:#a6e22e>R</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ObjectR</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>prototype</span> 
<span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>ObjectL</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>=</span> Function.<span style=color:#a6e22e>prototype</span> 

<span style=color:#a6e22e>R</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>L</span> 
<span style=color:#75715e>// 循环查找 L 是否还有 __proto__ 
</span><span style=color:#75715e></span><span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> Function.<span style=color:#a6e22e>prototype</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>prototype</span> 

<span style=color:#a6e22e>R</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>L</span> 
<span style=color:#75715e>// 返回 true
</span></code></pre></div><ul>
<li>String instanceof String</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>StringL</span> <span style=color:#f92672>=</span> String, <span style=color:#a6e22e>StringR</span> <span style=color:#f92672>=</span> String;

<span style=color:#a6e22e>R</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>StringR</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>prototype</span>
<span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>StringL</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>=</span> Function.<span style=color:#a6e22e>prototype</span>

<span style=color:#a6e22e>R</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>L</span>
<span style=color:#75715e>// 循环查找 L 是否还有 __proto__ 
</span><span style=color:#75715e></span><span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> Function.<span style=color:#a6e22e>prototype</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>prototype</span>
<span style=color:#a6e22e>R</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>L</span>
<span style=color:#75715e>// 接着查找
</span><span style=color:#75715e></span><span style=color:#a6e22e>L</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>
<span style=color:#75715e>// 返回 false
</span></code></pre></div><h2 id=一切皆对象>一切皆对象？<a hidden class=anchor aria-hidden=true href=#一切皆对象>#</a></h2>
<p>常常说 JavaScript 中一切皆对象，那么就有这样一个问题了：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#e6db74>&#39;string&#39;</span>.<span style=color:#ae81ff>__</span><span style=color:#a6e22e>proto__</span> <span style=color:#f92672>===</span> String.<span style=color:#a6e22e>prototype</span> <span style=color:#75715e>// true
</span><span style=color:#75715e></span><span style=color:#e6db74>&#39;string&#39;</span> <span style=color:#66d9ef>instanceof</span> String <span style=color:#75715e>// false
</span></code></pre></div><p>按照上面的推导，<code>'string' instanceof String</code> 应该为 <code>true</code>，但是我们得到的却是 <code>false</code>。
其实问题的关键在于：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>typeof</span> <span style=color:#e6db74>&#39;string&#39;</span>); <span style=color:#75715e>// string
</span></code></pre></div><p>&lsquo;string&rsquo; 并不是一个 object 对象，MDN 上对 instanceof 的定义是：</p>
<blockquote>
<p>The instanceof operator tests whether an object in its prototype chain has the prototype property of a constructor.</p>
</blockquote>
<p>这样又有一个问题了，既然字符串不是对象那为什么有对象才有的属性和方法呢？</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;string&#34;</span>;
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#ae81ff>2</span>);
</code></pre></div><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型: Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。</p>
<p>《JavaScript高级程序设计》中是这么解释的：</p>
<blockquote>
<p>上面的例子其实当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要 从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成：
(1) 创建 String 类型的一个实例;
(2) 在实例上调用指定的方法;
(3) 销毁这个实例。</p>
</blockquote>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> String(<span style=color:#e6db74>&#34;some text&#34;</span>);
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>s1</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#ae81ff>2</span>);
<span style=color:#a6e22e>s1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</code></pre></div><p>《Javascript权威指南》里说：</p>
<blockquote>
<p>其实（包装对象）在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样的。</p>
</blockquote>
<p>这样 Boolean、Number 是一样的逻辑。还剩下两种基本类型：null 和 undefined。</p>
<p>undefined 当我们对变量只声明没有初始化时，输出为 undefined，<code>typeof undefined</code> 返回的是 undefined 也不是 object 类型，所以 undefined 并不是任何对象的实例。</p>
<p>null 表示的是空对象，虽然 <code>typeof null</code> 是 object，但是 null 和 undefined 一样并没有任何属性和方法，在 instanceof 定义中也有判断，如果类型不是 object（这个类型判断并不是跟 typeof 返回值一样），就返回 false。
<img loading=lazy src=https://cdn.xieluping.cn/images/y560nlqtuhtfe48rpphkt9.png alt>
</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://gikey.github.io/tags/javascript/>JavaScript</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://gikey.github.io>Null</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>